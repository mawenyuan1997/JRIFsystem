// Assumes polyglot.jar is in classpath
include "polyglot/parse/java12.cup"

package jc.parse;

import jc.types.*;
import jc.ast.*;
import polyglot.parse.*;

parser Grm extends polyglot.parse.Grm  {:
  public final JcTypeSystem ts;
  public final JCNodeFactory nf;
  
  public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
    super(l, t, n, q);
    ts = (JcTypeSystem) t;
    nf = (JCNodeFactory) n;
  }
  
  public java_cup.runtime.Symbol parse() throws Exception {
  	java_cup.runtime.Symbol sym = super.parse();

    if (sym == null || sym.value == null) {
        return null;
    }

    Node n = (Node) sym.value;
    UnwrapVisitor unwrapper = new UnwrapVisitor();
    sym.value = n.visit(unwrapper);
    if (!unwrapper.isError()) return sym;
    else die(unwrapper.errorPos);
    return null;
  }
  
  public Position pos(ParserObject n) {
    if (n == null) {
  	  return null;
  	}
  	return n.pos;
  }
  
  public Position pos(TypeModelArgs n) {
  	if (n.typeArgs == null) return this.pos(n.modelArgs);
  	else return this.pos(n.typeArgs);
  }
  
	@Override
	protected Position posForObject(Object o) {
		if (o instanceof Amb) return pos((Amb) o);
		return super.posForObject(o);
	}
  
	// This method is to be called when processing "param_or_expr_list ::= expression | ... ". 
	public <T> List<T> makeList(T a) {
		List<T> l = new LinkedList<>();
		l.add(a);
		return l;
	}
	
	/** 
	 * Convert a param_or_expr_list to an expression. That is, it returns the only element in a param_or_expr_list.
	 */  
	public Expr listToExpr (List<Node> list) throws Exception {
		if (list.size() == 1 && (list.get(0) instanceof Expr)) {
			Expr expr = (Expr) list.get(0); // Note expr might be or contain a Wrapper. UnwrapVisitor needed. 
			return expr;
		} else {
			die(pos(list)); return null;
		}
	}
	
	/**
	 * Convert a param_or_expr_list to a list of type arguments.
	 */
	public List<TypeNode> listToTypes (List<Node> list) throws Exception {
		if (list.size() > 0) {
			List<TypeNode> res = new ArrayList<>(list.size());
			for (Node n : list) {
				if (n instanceof Expr) {
					res.add(exprToType((Expr) n));
				} else if (n instanceof TypeNode) {
					res.add((TypeNode) n);
				} else {
					die(pos(list)); return null;
				}
			}
			return res;
		} else {
			die(pos(list)); return null;
		} 
	} 
	
	/**
	 * Convert a param_or_expr_list_with_models to a list of type parameters.
	 * It simply tests if the <code>models</code> field is null, and calls 
	 * <code>listToTypeParams(List<Node>)</code>.
	 */
	public List<ParamTypeNode> listWithModelsToTypeParams (ListWithModels lwm) throws Exception {
		List<ParamTypeNode> RESULT = null;
		if (lwm.models == null) {
			List<Node> paramTypes = listToTypeParams(lwm.list);
			RESULT = new ArrayList<>(paramTypes.size());
			for (Node paramType : paramTypes)
				RESULT.add((ParamTypeNode) paramType);
		} else {
			die(pos(lwm.list)); return null;
		}
		return RESULT;
	}
	
	/**
	 * Convert a param_or_expr_list to a list of type parameters.
	 */
	public List<Node> listToTypeParams(List<Node> list) throws Exception {
		if (list != null && list.size() > 0) {
			List<Node> typeParams = new ArrayList<Node>(list.size());
			// Convert each element to ParamTypeNode.
			for (Node n : list) {
				if (n instanceof ParamTypeNode) {
					typeParams.add((ParamTypeNode) n);
					continue;
				}
				
				// Otherwise, each n should simply be an identifier.
				// If wrapped, unwrap first.
				if (n instanceof Wrapper) {
					n = ((Wrapper) n).amb.toExpr();
				}
				
				if (n instanceof AmbExpr) {
					typeParams.add(nf.ParamTypeNode(pos(n), ((AmbExpr)n).id(), null, null));
				} else if (n instanceof AmbTypeNode) {
					if (((AmbTypeNode) n).qual() == null) {
					typeParams.add(nf.ParamTypeNode(pos(n), ((AmbTypeNode)n).id(), null, null));
					} else { die(pos(list)); return null; }
				} else { die(pos(list)); return null; }
			}
			return typeParams;
		} else {
			die(pos(list)); return null;
		}
	}
	
	/**
	 * Bound the last ParamTypeNode in l with bound. upper indicates if it is an upper or lower bound.
	 * Prerequisite: Each element in l should be of type ParamTypeNode.
	 */ 
	public List<ParamTypeNode> appendTypeParamBound(List<ParamTypeNode> l, List<TypeNode> bound, boolean upper) throws Exception {
			ParamTypeNode last = l.get(l.size()-1);
		    if (!last.isBounded()) {
		      last = upper ? last.upperBounds(bound) : last.lowerBounds(bound);
		      l.remove(l.size()-1);
		      l.add(last);
		    } else { die(pos(bound)); }
		    return l;
	}
	
	public List<ParamTypeNode> idsToParams (List<Id> ids) {
		List<ParamTypeNode> params = new ArrayList<>();
		for (Id id : ids) {
			params.add(nf.ParamTypeNode(pos(id), id, null, null));
		}
		return params;
	}
	
	/**
	 * This is used when converting an expression in a param_or_expr_list to an object type. See the toType
	 * method in ObjTypeOrExpr for an example. 
	 * Note that unlike in its super-languages, exprToType is no longer directly used in cast_expression
	 * productions. 
	 */
	@Override
	public TypeNode exprToType(Expr e) throws Exception {
		// e can be a Wrapper. A non-Wrapper e must be AmbExpr/Field/ArrayAccess to be converted to
		// TypeNode.
		
		if (e instanceof Wrapper) {
			return ((Wrapper) e).amb.toType();
		} else if (e instanceof AmbExpr) {
			AmbExpr a = (AmbExpr) e;
			return nf.AmbTypeNode(pos(a), nf.Id(pos(a), a.name()));
		} else if (e instanceof Field) {
			// f.target() cannot be null; otherwise, it is resolved to AmbExpr.
			Field f = (Field) e;
			return nf.AmbTypeNode(pos(f), prefixToQualifier(f.target()), f.id());
		} else if (e instanceof ArrayAccess) {
			// XXX: This case seems unnecessary because those array accesses that can be converted to
			// type nodes are reduced to reftype_or_expr and are thus wrapped.
			ArrayAccess a = (ArrayAccess) e;
			
			if (a.array() instanceof ArrayAccess) {
				die(pos(e)); return null;
			} else {
				TypeNode typeArg = exprToType(a.index());
				List<TypeNode> typeArgs = new ArrayList<TypeNode>(1);
				typeArgs.add(typeArg);
				TypeNode base = exprToType(a.array());
				return nf.AmbTypeInstantiation(pos(a), base, typeArgs, null);
			}
		}
		
		die(pos(e)); return null;
	}
	
	/**
	 * Helper for prefixToQualifier
	 */
	@Override
	protected QualifierNode exprToQualifier(Expr e) throws Exception {
		// Very similar to exprToType(Expr).
		
		if (e instanceof Wrapper) {
			return ((Wrapper) e).amb.toQualifier();
		} else if (e instanceof AmbExpr) {
			AmbExpr a = (AmbExpr) e;
			return nf.AmbQualifierNode(pos(a), nf.Id(pos(a), a.name()));
		} else if (e instanceof Field) {
			Field f = (Field) e;
			return nf.AmbQualifierNode(pos(f), prefixToQualifier(f.target()), f.id());
		} else if (e instanceof ArrayAccess) {
			// XXX: This case seems unnecessary.
			return exprToType(e);
		} 
		die(pos(e)); return null;
	}
	
	/**
	 * Helper for exprToType
	 */
	@Override
	protected QualifierNode prefixToQualifier(Prefix p) throws Exception {
		if (p instanceof TypeNode) {
			// A non-ambiguous type node at the parsing stage may not be a qualifier.
			// XXX: this check seems to be already taken care of in type checking
			if (!(p instanceof AmbTypeNode)) { die(pos(p)); return null; }
			return (AmbTypeNode) p;
		} else if (p instanceof Expr) {
			return exprToQualifier((Expr) p);
		} else if (p instanceof AmbReceiver) {
			AmbReceiver a = (AmbReceiver) p;
			
			// Note that an AmbReceiver does not have brackets at the end.
			// (xx[xx] is resolved to ArrayAccess rather than AmbReceiver. See toReceiver method
			// in ObjTypeOrExpr.)
			
			if (a.prefix() == null) {
				return nf.AmbQualifierNode(pos(p), a.nameNode());
			} else {
				return nf.AmbQualifierNode(pos(p), prefixToQualifier(a.prefix()), a.nameNode());
			}
		} else if (p instanceof AmbPrefix) {
			AmbPrefix a = (AmbPrefix) p;
			
			// Note that an AmbPrefix either has no brackets at the end, or has exactly one pair
			// of brackets containing exactly one Expr.
			
			JCAmbPrefix ext = (JCAmbPrefix) a.ext();
			Expr bracket = ext.exprOrParam();
			if (bracket != null) { // JCAmbTypeInstantiation
				TypeNode typeArg = exprToType(bracket);
				List<TypeNode> typeArgs = new ArrayList(1);
				typeArgs.add(typeArg);
				
				TypeNode base;
				if (a.prefix() == null) {
					base = nf.AmbTypeNode(pos(a), a.nameNode());
				} else {
					base = nf.AmbTypeNode(pos(a), prefixToQualifier(a.prefix()), a.nameNode());
				}
				
				return nf.AmbTypeInstantiation(pos(a), base, typeArgs, null);
				
			} else { // AmbQualifierNode
				if (a.prefix() == null) {
					return nf.AmbQualifierNode(pos(a), a.nameNode());
				} else {
					return nf.AmbQualifierNode(pos(a), prefixToQualifier(a.prefix()), a.nameNode());
				}
			}
			
		}
		
		die(pos(p)); return null;
	}
	
	/**
	 * @return an ExistentialTypeNode constructed from a UseSiteParams and a quantified TypeNode.
	 */
	public TypeNode existentialTypeNode(UseSiteParams us, TypeNode quantifiedType) {
		Position pos = new Position(us.pos, quantifiedType.position());
		return nf.ExistentialTypeNode(pos, us.typeParams, us.typeConstraints, quantifiedType);
	}
	
	/**
	 * Check that {@code amb} is in the form of a dot-separated names
	 */
	public void checkCompoundName(Amb amb) throws Exception {
		if (amb instanceof ObjTypeOrExpr) {
			((ObjTypeOrExpr) amb).checkCompoundName();
		} else {
			die(amb.pos);
		}
	}
  
:};

// New terminals and nonterminals

terminal Token CONSTRAINT;
terminal Token MODEL;
terminal Token WHERE;
terminal Token WITH;
terminal Token USE;
terminal Token AS;
terminal Token ENRICH;
terminal Token TYPE;
terminal Token DOUBLECOLON;

non terminal TypeNode primitive_array_type;
non terminal List<Node> param_or_expr_list;
non terminal Amb reftype_or_expr;
non terminal ObjTypeOrExpr objtype_or_expr;
non terminal NameParams_or_VarDeclId methead_or_vardeclid;
non terminal Expr primary_no_new_array_or_this;
non terminal Expr primary_no_new_array_or_this_or_field_access;
non terminal PropertyAccess property_access;
non terminal ConstraintDecl constraint_declaration;
non terminal List<ConstraintNode> where_constraints_opt;
non terminal List<ConstraintNode> where_constraint_list;
non terminal ConstraintNode where_constraint;
non terminal List<TypeNode> constrained_types;
non terminal List<ExternalMethodDecl> constraint_body, model_body;
non terminal List<ExternalMethodDecl> constraint_method_decl_list, model_method_decl_list;
non terminal ExternalMethodDecl constraint_method_decl, model_method_decl;
non terminal TypeModelArgs generic_inst_args;
non terminal TypeModelArgs generic_inst_args_opt;
non terminal List<WitnessNode> model_argument_list;
non terminal WitnessNode model_argument;
non terminal ModelDecl model_declaration;
non terminal ListWithModels param_or_expr_list_with_models;
non terminal EnrichDecl enrich_declaration;

non terminal UseSiteParams use_site_params_opt;
non terminal UseSiteParams use_site_params;

non terminal AnnotationParens annotation_1;
non terminal FlagAnnotationsParens modifiers_or_annotations_1;
non terminal FlagAnnotationsParens modifiers_or_annotations_opt_1;
non terminal TypeNode existential_arraybase;
non terminal UseSiteParamsAndExArrayBase trailing_parens;
non terminal UseSiteParamsAndExArrayBase trailing_parens_opt;
non terminal TypeNode reftype_or_expr_1;
non terminal ModelMethodPartialSig model_method_partial_sig;

non terminal ExplicitDefaultBinding explicit_default_binding;
non terminal List<ExplicitDefaultBinding> explicit_default_bindings;
non terminal List<ExplicitDefaultBinding> explicit_default_bindings_opt;
non terminal List<TopLevelDecl> top_level_declarations;


non terminal Name type_variable;
non terminal List<ParamTypeNode> type_parameters, type_parameters_opt;
non terminal List<ParamTypeNode> type_parameter_list; 
non terminal List<TypeNode> type_bound;
non terminal TypeNode additional_bound;
non terminal List<TypeNode> additional_bound_list, additional_bound_list_opt;
non terminal TypeNode type_argument;
non terminal List<TypeNode> type_argument_list;

non terminal Loop foreach_statement, foreach_statement_no_short_if;
non terminal NewArray initialized_array_creation_expression;
non terminal ClassBody class_body_opt;

non terminal Expr instanceof_expression;
//// expressions which are Not a Name
non terminal Expr postfix_expression_nn;
non terminal Expr unary_expression_nn;
non terminal Expr unary_expression_not_plus_minus_nn;
non terminal Expr multiplicative_expression_nn;
non terminal Expr additive_expression_nn;
non terminal Expr shift_expression_nn;
non terminal Expr relational_expression_nn;
non terminal Expr instanceof_expression_nn;
non terminal Expr equality_expression_nn;
non terminal Expr and_expression_nn;
non terminal Expr exclusive_or_expression_nn;
non terminal Expr inclusive_or_expression_nn;
non terminal Expr conditional_and_expression_nn;
non terminal Expr conditional_or_expression_nn;
non terminal Expr conditional_expression_nn;
non terminal Expr assignment_expression_nn;
non terminal Expr expression_nn;

// annotation keyword 
terminal AT;
// non terminals added for annotations
non terminal ClassBody annotation_body;
non terminal List<ClassMember> annotation_type_element_declarations_opt;
non terminal List<ClassMember> annotation_type_element_declarations;
non terminal List<ClassMember> annotation_type_element_declaration;
non terminal Term element_value; // Term
non terminal Term default_value_opt; // Term
non terminal ElementValuePair element_value_pair;
non terminal List<ElementValuePair> element_value_pairs, element_value_pairs_opt;
non terminal ElementValueArrayInit element_value_array_initializer;
non terminal List<Term> element_values; // List


start with goal;

where_constraints_opt ::=
	WHERE:a where_constraint_list:b {: RESULT = b; :}
	|
	/* empty */ {: RESULT = new LinkedList<ConstraintNode>(); :}
	;

where_constraint_list ::=
	where_constraint:a
		{: List<ConstraintNode> l = new LinkedList<ConstraintNode>(); l.add(a); RESULT = l; :}
	|
	where_constraint_list:a COMMA where_constraint:c
		{: a.add(c); RESULT = a; :}
	;

where_constraint ::=
	name:a LBRACK constrained_types:b RBRACK
		{: RESULT = parser.nf.ConstraintNode(parser.pos(a,b), a.toAmbConceptNode(), b, null); :}
	|
	name:a LBRACK constrained_types:b RBRACK IDENTIFIER:c
		{: RESULT = parser.nf.ConstraintNode(parser.pos(a,b), a.toAmbConceptNode(), b, parser.nf.Id(parser.pos(c), c.getIdentifier())); :}
	;

constrained_types ::= // Can be any type. No longer restricted to object types. 
	reference_type:a
		{: RESULT = parser.<TypeNode> makeList(a); :}
	|
	primitive_type:a
		{: RESULT = parser.<TypeNode> makeList(a); :}
	|
	constrained_types:a COMMA:b reference_type:c
		{: a.add(c); RESULT = a; :}
	|
	constrained_types:a COMMA:b primitive_type:c
		{: a.add(c); RESULT = a; :}
	;

constraint_method_decl ::=
		// receiver explicit
	modifiers_or_annotations_opt_1:a type:b type_variable:c DOT:d 
		IDENTIFIER:e type_parameters_opt:f
		LPAREN formal_parameter_list_opt:h RPAREN dims_opt:j 
		where_constraints_opt:k throws_opt:l SEMICOLON:m
		{:	FlagAnnotations fl = a.flagAnnotations;
			TypeNode retType = a.parens != null ? a.parens.constructType(b) : b;
			MethodDecl md = parser.nf.MethodDecl(parser.pos(b,m,e), fl.flags(),  parser.array(retType, j.intValue()), parser.nf.Id(parser.pos(e), e.getIdentifier()), h, l, null, f, k);
			RESULT = parser.nf.ConstraintMethodDecl(parser.pos(b,m,e), c.toType(), md);
		:}
	|
	modifiers_or_annotations_opt_1:a dims:b type_variable:c DOT:d 
		IDENTIFIER:e type_parameters_opt:f
		LPAREN formal_parameter_list_opt:h RPAREN dims_opt:j 
		where_constraints_opt:k throws_opt:l SEMICOLON:m
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens == null) parser.die(parser.pos(a));
			TypeNode retType = a.parens.constructArrayType(b);
			MethodDecl md = parser.nf.MethodDecl(parser.pos(b,m,e), fl.flags(),  parser.array(retType, j.intValue()), parser.nf.Id(parser.pos(e), e.getIdentifier()), h, l, null, f, k);
			RESULT = parser.nf.ConstraintMethodDecl(parser.pos(b,m,e), c.toType(), md);
		:}
	|
	modifiers_or_annotations_opt_1:a VOID:b type_variable:c DOT:d 
		IDENTIFIER:e type_parameters_opt:f
		LPAREN formal_parameter_list_opt:h RPAREN 
		where_constraints_opt:k throws_opt:l SEMICOLON:m
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens != null) parser.die(a.parens.pos);
			MethodDecl md = parser.nf.MethodDecl(parser.pos(b,m,e), fl.flags(),  parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), parser.nf.Id(parser.pos(e), e.getIdentifier()), h, l, null, f, k);
			RESULT = parser.nf.ConstraintMethodDecl(parser.pos(b,m,e), c.toType(), md);
		:}
	|
		// receiver implicit
	modifiers_or_annotations_opt_1:a type:b 
			IDENTIFIER:e type_parameters_opt:f
			LPAREN formal_parameter_list_opt:h RPAREN dims_opt:j 
			where_constraints_opt:k throws_opt:l SEMICOLON:m
		{:	FlagAnnotations fl = a.flagAnnotations;
			TypeNode retType = a.parens != null ? a.parens.constructType(b) : b;
			MethodDecl md = parser.nf.MethodDecl(parser.pos(b,m,e), fl.flags(),  parser.array(retType, j.intValue()), parser.nf.Id(parser.pos(e), e.getIdentifier()), h, l, null, f, k);
			RESULT = parser.nf.ConstraintMethodDecl(parser.pos(b,m,e), null, md);
		:}
	|
	modifiers_or_annotations_opt_1:a dims:b 
			IDENTIFIER:e type_parameters_opt:f
			LPAREN formal_parameter_list_opt:h RPAREN dims_opt:j 
			where_constraints_opt:k throws_opt:l SEMICOLON:m
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens == null) parser.die(parser.pos(a));
			TypeNode retType = a.parens.constructArrayType(b);
			MethodDecl md = parser.nf.MethodDecl(parser.pos(b,m,e), fl.flags(),  parser.array(retType, j.intValue()), parser.nf.Id(parser.pos(e), e.getIdentifier()), h, l, null, f, k);
			RESULT = parser.nf.ConstraintMethodDecl(parser.pos(b,m,e), null, md);
		:}
	|
	modifiers_or_annotations_opt_1:a VOID:b 
			IDENTIFIER:e type_parameters_opt:f
			LPAREN formal_parameter_list_opt:h RPAREN 
			where_constraints_opt:k throws_opt:l SEMICOLON:m
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens != null) parser.die(a.parens.pos);
			MethodDecl md = parser.nf.MethodDecl(parser.pos(b,m,e), fl.flags(),  parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), parser.nf.Id(parser.pos(e), e.getIdentifier()), h, l, null, f, k);
			RESULT = parser.nf.ConstraintMethodDecl(parser.pos(b,m,e), null, md);
		:}
	;

constraint_method_decl_list ::=
	constraint_method_decl:a
		{: RESULT = new ArrayList<ExternalMethodDecl>(0); RESULT.add(a); :}
	|
	constraint_method_decl_list:a constraint_method_decl:b
		{: a.add(b); RESULT = a; :}
	;

constraint_body ::=
	LBRACE:a constraint_method_decl_list:b RBRACE:c
		{: RESULT = b; :}
	;

constraint_declaration ::=
	modifiers_or_annotations_opt_1:a CONSTRAINT:b IDENTIFIER:c type_parameters:d where_constraints_opt:e constraint_body:f
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens != null) parser.die(a.parens.pos);
			RESULT = parser.nf.ConstraintDecl(parser.pos(b,f,c), fl.flags(), parser.nf.Id(parser.pos(c), c.getIdentifier()), d, e, f);
		:}
	;

/* Example:
	use [E] CompareList[E with o] for Comparable[List[E]] where Comparable[E];
	use [E] CompareList[E with o] where Comparable[E];
*/
explicit_default_binding ::=
	USE:a type_parameters_opt:b model_argument:c FOR name:d LBRACK constrained_types:e RBRACK:f where_constraints_opt:g SEMICOLON:h
		{:	RESULT = parser.nf.ExplicitDefaultBinding(parser.pos(a,h,c), c, d.toAmbConceptNode(), e, b, g); :}
	|
	USE:a type_parameters_opt:b model_argument:c where_constraints_opt:g SEMICOLON:h
		{:	RESULT = parser.nf.ExplicitDefaultBinding(parser.pos(a,h,c), c, null, null, b, g); :}
	;	
	
explicit_default_bindings ::=
	explicit_default_binding:a {: RESULT = parser.<ExplicitDefaultBinding> makeList(a); :}
	|
	explicit_default_bindings:a explicit_default_binding:b {: RESULT = a; a.add(b); :}
	;

explicit_default_bindings_opt ::=
	/* empty */ {: RESULT = null; :}
	|
	explicit_default_bindings:a {: RESULT = a; :}
	;

top_level_declarations ::=
	constraint_declaration:a {: RESULT = parser.<TopLevelDecl> makeList(a); :}
	|
	model_declaration:a {: RESULT = parser.<TopLevelDecl> makeList(a); :}
	|
	enrich_declaration:a {: RESULT = parser.<TopLevelDecl> makeList(a); :}
	|
	type_declarations_opt:a {: RESULT = a; :}
	;

override compilation_unit ::=
	package_declaration_opt:a
    import_declarations_opt:b
    explicit_default_bindings_opt:c
    top_level_declarations:d
        {: RESULT = parser.nf.SourceFile(new Position(parser.lexer.path(), parser.lexer.file()), a, b, c, d); :}
	|
	error
	type_declarations_opt:c
		{: RESULT = parser.nf.SourceFile(new Position(parser.lexer.path(), parser.lexer.file()),
			null, Collections.<Import> emptyList(), c); :}
	;

model_argument ::=
	objtype_or_expr:a
		{: RESULT = a.toAmbExpanderNode(); :}
	|
	COMP:a
		{: RESULT = parser.nf.DefaultWitness(parser.pos(a)); :}
	;

model_argument_list ::=
	model_argument:a
		{: List<WitnessNode> l = new LinkedList<>(); l.add(a); RESULT = l; :}
	|
	model_argument_list:a COMMA model_argument:c
		{: RESULT = a; a.add(c); :}
	;

generic_inst_args_opt ::=
	/* empty */ {: RESULT = null; :}
	|
	generic_inst_args:a {: RESULT = a; :}
	;

generic_inst_args ::=
	LBRACK:a type_argument_list:b RBRACK:e
		{: RESULT = new TypeModelArgs(b, null); :}
	|
	LBRACK:a type_argument_list:b WITH model_argument_list:d RBRACK:e
		{: RESULT = new TypeModelArgs(b, d); :}
	|
	LBRACK:a WITH model_argument_list:d RBRACK:e
		{: RESULT = new TypeModelArgs(null, d); :}
	;

model_declaration ::=
	modifiers_or_annotations_opt_1:a MODEL:b IDENTIFIER:c type_parameters_opt:d FOR:e name:f generic_inst_args:g where_constraints_opt:h model_body:i
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens != null) parser.die(a.parens.pos);
			RESULT = parser.nf.ModelDecl(parser.pos(a,c,i), fl.flags(), parser.nf.Id(parser.pos(c), c.getIdentifier()), d, f.toAmbConceptNode(), g.typeArgs, g.modelArgs, h, i); :}
	;
	
model_body ::=
	LBRACE:a model_method_decl_list:b RBRACE:c
		{: RESULT = b; :}
	;

model_method_decl_list ::=
	model_method_decl:a
		{: List<ExternalMethodDecl> l = new LinkedList<>(); l.add(a); RESULT = l; :}
	|
	model_method_decl_list:a model_method_decl:b
		{: RESULT = a; a.add(b); :}
	;

model_method_decl ::=
	modifiers_or_annotations_opt_1:a type:b
	model_method_partial_sig:c
	LPAREN formal_parameter_list_opt:e RPAREN
	dims_opt:g where_constraints_opt:h throws_opt:i method_body:j
		// return type is neither void, nor an array type with an existential base type.
		{:	FlagAnnotations fl = a.flagAnnotations;
			TypeNode retType = a.parens != null ? a.parens.constructType(b) : b;	
			Id methodId = c.methodId;
			TypeNode receiverType = c.receiverType;
			List<ParamTypeNode> l = c.typeParams;
			MethodDecl md = parser.nf.MethodDecl(parser.pos(b,i,c), fl.flags(),  parser.array(retType, g.intValue()), methodId, e, i, j, l, h);
			RESULT = parser.nf.ModelMethodDecl(parser.pos(b,i,c), receiverType, md);
		:}
	|
	
	modifiers_or_annotations_opt_1:a dims:b
	model_method_partial_sig:c
	LPAREN formal_parameter_list_opt:e RPAREN
	dims_opt:g where_constraints_opt:h throws_opt:i method_body:j
		// return type is an array with an existential base type.
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens == null) parser.die(parser.pos(a));
			TypeNode retType = a.parens.constructArrayType(b);	
			Id methodId = c.methodId;
			TypeNode receiverType = c.receiverType;
			List<ParamTypeNode> l = c.typeParams;
			MethodDecl md = parser.nf.MethodDecl(parser.pos(b,i,c), fl.flags(),  parser.array(retType, g.intValue()), methodId, e, i, j, l, h);
			RESULT = parser.nf.ModelMethodDecl(parser.pos(b,i,c), receiverType, md);
		:}

	|
	
	modifiers_or_annotations_opt_1:a VOID:b
	model_method_partial_sig:c
	LPAREN formal_parameter_list_opt:e RPAREN 
	where_constraints_opt:h throws_opt:i method_body:j
		// return type is void
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens != null) parser.die(a.parens.pos);
			Id methodId = c.methodId;
			TypeNode receiverType = c.receiverType;
			List<ParamTypeNode> l = c.typeParams;
			MethodDecl md = parser.nf.MethodDecl(parser.pos(b,i,c), fl.flags(),  parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), methodId, e, i, j, l, h);
			RESULT = parser.nf.ModelMethodDecl(parser.pos(b,i,c), receiverType, md);
		:}
	;
	
	
param_or_expr_list_with_models ::=
	param_or_expr_list:a
		{: RESULT = new ListWithModels(parser, parser.pos(a), a, null); :}
	|
	param_or_expr_list:a WITH model_argument_list:c
		{: RESULT = new ListWithModels(parser, parser.pos(a,c), a, c); :}
	|
	WITH:b model_argument_list:c
		{: RESULT = new ListWithModels(parser, parser.pos(c), null, c); :}
	;
	
enrich_declaration ::=
	modifiers_or_annotations_opt_1:a ENRICH:b name:c type_parameters_opt:d where_constraints_opt:e model_body:f		
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens != null) parser.die(a.parens.pos);
			RESULT = parser.nf.EnrichDecl(parser.pos(b, f, c), fl.flags(), c.toAmbWitnessNode(), d, e, f); :}
	;

use_site_params_opt ::= 
	use_site_params:a {: RESULT = a; :}
	|
	/* empty */ {:RESULT = null; :}
	;

use_site_params ::=
	LPAREN:a TYPE:b type_parameter_list:c where_constraints_opt:d RPAREN:e
		{: RESULT = new UseSiteParams(parser, parser.pos(a,e), c, d); :}
	|
	LPAREN:a WHERE where_constraint_list:c RPAREN:d
		{: RESULT = new UseSiteParams(parser, parser.pos(a, d), null, c); :}
	;

drop{modifiers}
drop{modifiers_opt}

// Start grouping trailing parentheses into annotation to resolve shift/reduce conflicts. 

// JL5 annotation possibly followed by use_site_params.
// It is supposed to replace JL5 annotation in Jc.
annotation_1 ::=
/*	AT name:b
		{:	AnnotationElem n = parser.nf.MarkerAnnotationElem(parser.pos(b), b.toType());
			RESULT = new AnnotationParens(parser, parser.pos(b), n, null);
		:}
	|
	AT name:b LPAREN element_value:d RPAREN
		{:	AnnotationElem n = parser.nf.SingleElementAnnotationElem(parser.pos(b), b.toType(), d);
			RESULT = new AnnotationParens(parser, parser.pos(b), n, null);
		:}	
	|	
	AT name:b LPAREN element_value_pairs_opt:d RPAREN
		{:	AnnotationElem n = parser.nf.NormalAnnotationElem(parser.pos(b), b.toType(), d);
			RESULT = new AnnotationParens(parser, parser.pos(b), n, null);
		:}
	|
	AT name:b trailing_parens:c
		{:	AnnotationElem n = parser.nf.MarkerAnnotationElem(parser.pos(b), b.toType());
			RESULT = new AnnotationParens(parser, parser.pos(b), n, c);
		:}
	|
	AT name:b LPAREN element_value:d RPAREN trailing_parens:f
		{:	AnnotationElem n = parser.nf.SingleElementAnnotationElem(parser.pos(b), b.toType(), d);
			RESULT = new AnnotationParens(parser, parser.pos(b), n, f);
		:}	
	|
	AT name:b LPAREN element_value_pairs_opt:d RPAREN trailing_parens:f
		{:	AnnotationElem n = parser.nf.NormalAnnotationElem(parser.pos(b), b.toType(), d);
			RESULT = new AnnotationParens(parser, parser.pos(b), n, f);
		:}
*/	AT name:b trailing_parens:c
		{:	RESULT = new AnnotationParens(parser, parser.pos(b), null, c);
		:}
	;

// Existentially quantified array base type.
// The parens are to make the existential binding point explicit.
// Example: suppose we have a return type
//		(type T)((? U)((? T) L[K[T], U][])[])[]
// - (type T) is part of modifiers_or_annotations_opt_1
// - ((? U)((? T) L[K[T], U][])[]) is existential_arraybase
// - and [] is dims
// Also remember that Java lets you put return type dims after method formal parameters.
existential_arraybase ::=
	LPAREN use_site_params:b reftype_or_expr:c RPAREN
		{: RESULT = parser.existentialTypeNode(b, c.toType()); :}
	|
	LPAREN use_site_params:b existential_arraybase:c RPAREN
		{: RESULT = parser.existentialTypeNode(b, c); :}
	;

// use_site_params and/or existential_arraybase following modifiers_or_annotations
trailing_parens ::=
	use_site_params:a
		{: RESULT = new UseSiteParamsAndExArrayBase(parser, parser.pos(a), a, null); :}
	|
	existential_arraybase:a
		{: RESULT = new UseSiteParamsAndExArrayBase(parser, parser.pos(a), null, a); :}
	|
	use_site_params:a existential_arraybase:b
		{: RESULT = new UseSiteParamsAndExArrayBase(parser, parser.pos(a), a, b); :}
	;

trailing_parens_opt ::=
	/* empty */ {: RESULT = null; :}
	|
	trailing_parens:a {: RESULT = a; :}
	;

// modifiers_or_annotatinos with trailing parentheses.
modifiers_or_annotations_1 ::=
	modifier:a trailing_parens_opt:b
		{:	FlagAnnotations fl = new FlagAnnotations();
			RESULT = new FlagAnnotationsParens(parser, parser.position(), fl.flags(a), b);
		:}
	|	
	annotation_1:a
		{:	FlagAnnotations fl = new FlagAnnotations();
			RESULT = new FlagAnnotationsParens(parser, parser.position(), fl.addAnnotation(a.annotation), a.parens);
		:}
	|
	modifiers_or_annotations_1:a modifier:b trailing_parens_opt:c
		{:	if (a.parens != null) parser.die(a.parens.pos);
			if (a.flagAnnotations.flags().intersects(b)) parser.die(parser.position());
			RESULT = a;
			a.flagAnnotations = a.flagAnnotations.flags(a.flagAnnotations.flags().set(b));
			a.parens = c;
		:}
	|
	modifiers_or_annotations_1:a annotation_1:b
		{:	if (a.parens != null) parser.die(a.parens.pos);
			RESULT = a;
			a.flagAnnotations.addAnnotation(b.annotation);
			a.parens = b.parens;
		:}
	;

modifiers_or_annotations_opt_1 ::=
	trailing_parens_opt:a
		{: RESULT = new FlagAnnotationsParens(parser, parser.pos(a), new FlagAnnotations(), a); :}
	|
	modifiers_or_annotations_1:a
		{: RESULT = new FlagAnnotationsParens(parser, parser.pos(a), a.flagAnnotations, a.parens); :}
	;
/*
element_value ::=
	element_value_array_initializer:a {: RESULT = a; :}
	|
    conditional_expression:a {: RESULT = a; :}
    |
    annotation_1:a
    	{:	if (a.parens != null) parser.die(a.parens.pos);
    		RESULT = a.annotation;
    	:}
	;
*/
override synchronized_statement ::=
                    // Synchronized
	modifier:n LPAREN expression:a RPAREN block:b
		{:	if (n.equals(Flags.SYNCHRONIZED)) 
				RESULT = parser.nf.Synchronized(parser.pos(n, b), a, b);
			else
				parser.die(parser.position());
		:}	
	;

// End grouping 

// Start refactoring non terminals due to changes to modifiers_or_annotations
/*
annotation_type_element_declaration ::=
	modifiers_or_annotations_opt_1:a type:b IDENTIFIER:c LPAREN RPAREN default_value_opt:d SEMICOLON:e
		{:	FlagAnnotations fl = a.flagAnnotations;
			TypeNode type = a.parens != null ? a.parens.constructType(b) : b;
			RESULT = parser.<ClassMember> makeList(parser.nf.AnnotationElemDecl(parser.pos(b,e), fl.flags(), type, parser.nf.Id(parser.pos(c), c.getIdentifier()), d));
		:}
	|
	modifiers_or_annotations_opt_1:a dims:b IDENTIFIER:c LPAREN RPAREN default_value_opt:d SEMICOLON:e
		{:	FlagAnnotations fl = a.flagAnnotations;
			if (a.parens == null) parser.die(parser.position());
			TypeNode type = a.parens.constructArrayType(b);
			RESULT = parser.<ClassMember> makeList(parser.nf.AnnotationElemDecl(parser.pos(b,e), fl.flags(), type, parser.nf.Id(parser.pos(c), c.getIdentifier()), d));
		:}
	|
	constant_declaration:a {: RESULT = a; :}
	|
	class_declaration:a {: RESULT = parser.<ClassMember> makeList(a); :}
	|
	interface_declaration:a {: RESULT = parser.<ClassMember> makeList(a); :}
	|
	SEMICOLON {: RESULT = Collections.<ClassMember> emptyList(); :}
    ;
*/
override field_declaration ::=
    modifiers_or_annotations_opt_1:a type:b variable_declarators:c SEMICOLON:e
    	{:	FlagAnnotations fl = a.flagAnnotations;
    		TypeNode type = a.parens != null ? a.parens.constructType(b) : b;
    		// A field of an existential type cannot be declared together with other variables. 
    		if (type instanceof ExistentialTypeNode && c.size() > 1) {
    			for (VarDeclarator d : c) {
    				if (d.dims == 0) parser.die(d.pos);
    			}
    		}
    		List<ClassMember> l = new LinkedList<>();
    		for (VarDeclarator d : c) {
    			l.add(parser.nf.FieldDecl(parser.pos(b,e), fl.flags(), parser.array(type, d.dims), d.name, d.init));
    		}
    		RESULT = l;
    	:}
    |
    modifiers_or_annotations_opt_1:a type:b variable_declarator_id:c EQ variable_initializer:e WITH:f model_argument_list:g SEMICOLON:h
    	{:	FlagAnnotations fl = a.flagAnnotations;
    		TypeNode type = a.parens != null ? a.parens.constructType(b) : b;
    		VarDeclarator varDecl = c;
    		c.init = parser.nf.ExprWith(parser.pos(e,g), e, g);
    		RESULT = parser.<ClassMember> makeList(parser.nf.FieldDecl(parser.pos(a,h), fl.flags(), parser.array(type, c.dims), varDecl.name, varDecl.init));
    		// Delay the checking of whether the type is an existential to type checking.
    	:}
    |
    modifiers_or_annotations_opt_1:a dims:b variable_declarators:c SEMICOLON:e
    	{:	if (a.parens == null) parser.die(parser.position());
    		FlagAnnotations fl = a.flagAnnotations;
    		TypeNode type = a.parens.constructArrayType(b);
    		List<ClassMember> l = new LinkedList<>();
    		for (VarDeclarator d : c) {
    			l.add(parser.nf.FieldDecl(parser.pos(b,e), fl.flags(), parser.array(type, d.dims), d.name, d.init));
    		}
    		RESULT = l;
    	:}
    ;

override formal_parameter ::=
    modifiers_or_annotations_opt_1:a type:b variable_declarator_id:c
    	{:	FlagAnnotations fl = a.flagAnnotations;
    		TypeNode type = a.parens != null ? a.parens.constructType(b) : b;
    		RESULT = parser.nf.Formal(parser.pos(b, c, c), fl.flags(), 
				parser.array(type, c.dims), c.name);
    	:}
    |
    modifiers_or_annotations_opt_1:a dims:b variable_declarator_id:c
    	{:	if (a.parens == null) parser.die(parser.position());
    		FlagAnnotations fl = a.flagAnnotations;
    		TypeNode type = a.parens.constructArrayType(b);
    		RESULT = parser.nf.Formal(parser.pos(a, c, c), fl.flags(), 
				parser.array(type, c.dims), c.name);
    	:}
	;

override local_variable_declaration ::=
	type:a variable_declarators:b
		{: RESULT = parser.variableDeclarators(a, b, Flags.NONE); :}
	|
	use_site_params:a type:b variable_declarators:c
		{:	// A local of an existential type cannot be declared together with other variables. 
			if (c.size() > 1) {
				for (VarDeclarator d : c) {
					if (d.dims == 0) parser.die(d.pos);
				}
			}
			RESULT = parser.variableDeclarators(parser.existentialTypeNode(a, b), c, Flags.NONE);
		:}
	|
	use_site_params:a type:b variable_declarator_id:c EQ variable_initializer:e WITH:f model_argument_list:g
		{:	TypeNode type = parser.existentialTypeNode(a, b);
			VarDeclarator varDecl = c;
			c.init = parser.nf.ExprWith(parser.pos(e,g), e, g);
			RESULT = parser.<LocalDecl> makeList(parser.nf.LocalDecl(parser.pos(a,g), Flags.NONE, parser.array(type, c.dims), varDecl.name, varDecl.init));
		:}
	|
	existential_arraybase:a dims:b variable_declarators:c
		{: RESULT = parser.variableDeclarators(parser.array(a, b), c, Flags.NONE); :}
	|
	use_site_params:a existential_arraybase:b dims:c variable_declarators:e
		{:	// A local of an existential type cannot be declared together with other variables. 
			if (e.size() > 1) {
				for (VarDeclarator d : e) {
					if (d.dims == 0) parser.die(d.pos);
				}
			}
			RESULT = parser.variableDeclarators(parser.existentialTypeNode(a, parser.array(b, c)), e, Flags.NONE);
		:}
	|
	use_site_params:a existential_arraybase:b dims:c variable_declarator_id:e EQ variable_initializer:f WITH:g model_argument_list:h
		{:	TypeNode type = parser.existentialTypeNode(a, parser.array(b, c));
			VarDeclarator varDecl = e;
			e.init = parser.nf.ExprWith(parser.pos(f,h), f, h);
			RESULT = parser.<LocalDecl> makeList(parser.nf.LocalDecl(parser.pos(a,h), Flags.NONE, parser.array(type, e.dims), varDecl.name, varDecl.init));
		:}
	|
	modifiers_or_annotations_1:a type:b variable_declarators:c
		{:	FlagAnnotations fl = a.flagAnnotations;
			TypeNode type = a.parens != null ? a.parens.constructType(b) : b;
			RESULT = parser.variableDeclarators(type, c, fl.flags());
		:}
	|
	modifiers_or_annotations_1:a dims:b variable_declarators:c
		{:	if (a.parens == null) parser.die(parser.position());
			FlagAnnotations fl = a.flagAnnotations;
			TypeNode type = a.parens.constructArrayType(b);
			RESULT = parser.variableDeclarators(type, c, fl.flags());
		:}
	;

/*foreach_statement ::=
	FOR:a LPAREN type:c variable_declarator_id:d COLON expression:f RPAREN statement:h
		{:	LocalDecl ld = parser.nf.LocalDecl(parser.pos(c,d), Flags.NONE, c, d.name()); 
			RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h);
		:}
	|
	FOR:a LPAREN use_site_params:b type:c variable_declarator_id:d COLON expression:f RPAREN statement:h
		{:	LocalDecl ld = parser.nf.LocalDecl(parser.pos(b,d), Flags.NONE, parser.existentialTypeNode(b,c), d.name()); 
			RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h);
		:}
	|
	FOR:a LPAREN existential_arraybase:b dims:c variable_declarator_id:d COLON expression:f RPAREN statement:h
		{:	LocalDecl ld = parser.nf.LocalDecl(parser.pos(b,d), Flags.NONE, parser.array(b,c), d.name()); 
			RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h);
		:}
	|
	FOR:a LPAREN use_site_params:j existential_arraybase:b dims:c variable_declarator_id:d COLON expression:f RPAREN statement:h
		{:	LocalDecl ld = parser.nf.LocalDecl(parser.pos(j,d), Flags.NONE, parser.existentialTypeNode(j, parser.array(b,c)), d.name()); 
			RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h);
		:}
	|
	FOR:a LPAREN modifiers_or_annotations_1:c type:d variable_declarator_id:e COLON expression:g RPAREN statement:i
		{:	FlagAnnotations fl = c.flagAnnotations;
			TypeNode type = c.parens != null ? c.parens.constructType(d) : d;
			LocalDecl ld = parser.nf.LocalDecl(parser.pos(d,e), fl.flags(),  type, e.name(), null); 
    	    RESULT = parser.nf.ExtendedFor(parser.pos(a, i), ld, g, i);
		:}
	|
	FOR:a LPAREN modifiers_or_annotations_1:c dims:d variable_declarator_id:e COLON expression:g RPAREN statement:i
		{:	if (c.parens == null) parser.die(parser.position());
			FlagAnnotations fl = c.flagAnnotations;
			TypeNode type = c.parens.constructArrayType(d);
			LocalDecl ld = parser.nf.LocalDecl(parser.pos(d,e), fl.flags(),  type, e.name(), null); 
    	    RESULT = parser.nf.ExtendedFor(parser.pos(a, i), ld, g, i);
		:}
	;

foreach_statement_no_short_if ::=
	FOR:a LPAREN type:c variable_declarator_id:d COLON expression:f RPAREN statement_no_short_if:h
		{:	LocalDecl ld = parser.nf.LocalDecl(parser.pos(c,d), Flags.NONE, c, d.name(), null);  
			RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h);
		:}
	|
	FOR:a LPAREN use_site_params:b type:c variable_declarator_id:d COLON expression:f RPAREN statement_no_short_if:h
		{:	LocalDecl ld = parser.nf.LocalDecl(parser.pos(c,d), Flags.NONE, parser.existentialTypeNode(b,c), d.name(), null);  
			RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h);
		:}
	|
	FOR:a LPAREN existential_arraybase:b dims:c variable_declarator_id:d COLON expression:f RPAREN statement_no_short_if:h
		{:	LocalDecl ld = parser.nf.LocalDecl(parser.pos(c,d), Flags.NONE, parser.array(b,c), d.name(), null);
			RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h);
		:}
	|
	FOR:a LPAREN use_site_params:j existential_arraybase:b dims:c variable_declarator_id:d COLON expression:f RPAREN statement_no_short_if:h
		{:	LocalDecl ld = parser.nf.LocalDecl(parser.pos(c,d), Flags.NONE, parser.existentialTypeNode(j, parser.array(b,c)), d.name(), null);  
			RESULT = parser.nf.ExtendedFor(parser.pos(a, h), ld, f, h);
		:}
	|
	FOR:a LPAREN modifiers_or_annotations_1:c type:d variable_declarator_id:e COLON expression:g RPAREN statement_no_short_if:i
		{:	FlagAnnotations fl = c.flagAnnotations;
			TypeNode localType = c.parens != null ? c.parens.constructType(d) : d; 
			LocalDecl ld = parser.nf.LocalDecl(parser.pos(d,e), fl.flags(),  localType, e.name(), null);
			RESULT = parser.nf.ExtendedFor(parser.pos(a, i), ld, g, i);
		:}
	|
	FOR:a LPAREN modifiers_or_annotations_1:c dims:d variable_declarator_id:e COLON expression:g RPAREN statement_no_short_if:i
		{:	if (c.parens == null) parser.die(c.pos.endOf());
			FlagAnnotations fl = c.flagAnnotations;
			TypeNode localType = c.parens.constructArrayType(d); 
			LocalDecl ld = parser.nf.LocalDecl(parser.pos(d,e), fl.flags(),  localType, e.name(), null);
			RESULT = parser.nf.ExtendedFor(parser.pos(a, i), ld, g, i);
		:}
	;
*/
// End refactoring non terminals due to changes to modifiers_or_annotations
//////////////////////////////////////////////////////////////////////////////////////////////

override simple_name ::=
	IDENTIFIER:a
		{: RESULT = new Name(parser, parser.pos(a), null, parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
	;

override qualified_name ::=
	name:a DOT IDENTIFIER:b
		{: RESULT = new Name(parser, parser.pos(a,b), a, parser.nf.Id(parser.pos(b), b.getIdentifier())); :}
	;
	
override identifier_opt ::=
	/* empty */ {: RESULT = null; :}
	|
	IDENTIFIER:a
		{: RESULT = new Name(parser, parser.pos(a), null, parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
	;

type_variable ::=
	IDENTIFIER:a
		{: RESULT = new Name(parser, parser.pos(a), null, parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
	;
	
// Type Parameters

type_parameters ::=
	LBRACK type_parameter_list:a RBRACK
		{: RESULT = a; :}
	;

type_parameters_opt ::=
	/* empty */ {: RESULT = null; :}
	|
	type_parameters:a {: RESULT = a; :}
	;

type_parameter_list ::=
	type_parameter_list:a COMMA type_variable:c
		{: a.add(parser.nf.ParamTypeNode(parser.pos(c), c.name, null, null)); RESULT = a; :}
	|
	type_variable:a
		{: RESULT = parser.<ParamTypeNode> makeList(parser.nf.ParamTypeNode(parser.pos(a), a.name, null, null)); :}
	|
	type_parameter_list:a EXTENDS type_bound:c
		{: RESULT = parser.appendTypeParamBound(a, c, true); :}
	|
	type_parameter_list:a SUPER reference_type:c
		{:	List<TypeNode> bound = parser.<TypeNode>makeList(c);
			RESULT = parser.appendTypeParamBound(a, bound, false);
		:}
	;

type_bound ::=
	reference_type:a additional_bound_list_opt:b
		{:	if (b == null)
				RESULT = parser.<TypeNode> makeList(a);
			else {
				b.add(0, a);
				RESULT = b;
			}                
		:}
	;

additional_bound_list_opt ::= 
    additional_bound_list:a
    {: RESULT = a; :}
    |
    {: RESULT = null; :}
;
additional_bound_list ::=
		additional_bound:a additional_bound_list:b
        {: b.add(0, a);
           RESULT = b; :}
	|	additional_bound:a
        {: List<TypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l; :}
	;
additional_bound ::=
		AND interface_type:a
        {: RESULT = a; :}
	;

/* A list of expressions, or type arguments, or type parameters appearing between brackets
 */
param_or_expr_list ::=
	expression:a
		// array access index expression or type argument or type parameter. (the nonterminal 
		// "expression" is a superset of reftype_or_expr)
		{: RESULT = parser.<Node>makeList(a); :}
	|
	primitive_type:a
		{: RESULT = parser.<Node>makeList(a); :}
	|
		// The next 3 productions, together with the last one, can represent all reference types.
	use_site_params:a reftype_or_expr:b
		{: RESULT = parser.<Node>makeList(parser.existentialTypeNode(a, b.toType())); :}
	|
	existential_arraybase:a dims:b
		{: RESULT = parser.<Node>makeList(parser.array(a, b)); :}
	|
	use_site_params:a existential_arraybase:b dims:c
		{: RESULT = parser.<Node>makeList(parser.existentialTypeNode(a, parser.array(b, c))); :}
	|
	param_or_expr_list:a COMMA reference_type:c
		// type argument list or type paramter list
		{: a.add(c); RESULT = a; :}
	|
	param_or_expr_list:a COMMA primitive_type:c
		{: a.add(c); RESULT = a; :}
	|
	IDENTIFIER:a EXTENDS type_bound:c
		{:	RESULT = parser.<Node>makeList(parser.nf.ParamTypeNode(parser.pos(a,c), parser.nf.Id(parser.pos(a), a.getIdentifier()), c, null)); :}
	|
	param_or_expr_list:a COMMA IDENTIFIER:c EXTENDS type_bound:e
		{:	RESULT = a; RESULT.add(parser.nf.ParamTypeNode(parser.pos(a,e), parser.nf.Id(parser.pos(c), c.getIdentifier()), e, null)); :}
	|
	IDENTIFIER:a SUPER reference_type:c
		{:	List<TypeNode> bound = parser.<TypeNode>makeList(c);
			RESULT = parser.<Node>makeList(parser.nf.ParamTypeNode(parser.pos(a,c), parser.nf.Id(parser.pos(a), a.getIdentifier()), null, bound));
		:}
	|
	param_or_expr_list:a COMMA IDENTIFIER:c SUPER reference_type:e
		{:	List<TypeNode> bound = parser.<TypeNode>makeList(e);
			RESULT = a; RESULT.add(parser.nf.ParamTypeNode(parser.pos(a,e), parser.nf.Id(parser.pos(c), c.getIdentifier()), null, bound)); :}
	;


// Types

/* types excluing
 * - existential types, and
 * - array types whose ultimate base type is existential
 */
override type ::=
		primitive_type:a
		{: RESULT = a; :}
	|	reftype_or_expr:a
		{: RESULT = a.toType(); :}
	|	primitive_array_type:a
		{: RESULT = a; :}
	;

drop {array_type}

override reference_type ::=
		primitive_array_type:a
		{: RESULT = a; :}
	|	reftype_or_expr_1:a
		{: RESULT = a; :}
	|	use_site_params:a reftype_or_expr_1:b
		{: RESULT = parser.existentialTypeNode(a, b); :}
	;

override class_or_interface_type ::=
		objtype_or_expr:a
		{: RESULT = a.toType(); :}
	|	use_site_params:a objtype_or_expr:b
	;
	
primitive_array_type ::=
	primitive_type:a LBRACK RBRACK:c
		{:	if (!(a instanceof CanonicalTypeNode)) parser.die(parser.pos(a,c));
			Type t =  ((CanonicalTypeNode) a).type();
			RESULT = parser.nf.CanonicalTypeNode(parser.pos(a,c), parser.ts.arrayOf(t,1)); :}
	|
	primitive_array_type:a LBRACK RBRACK:c
		{:	if (!(a instanceof CanonicalTypeNode)) parser.die(parser.pos(a,c));
			Type t =  ((CanonicalTypeNode) a).type();
			RESULT = parser.nf.CanonicalTypeNode(parser.pos(a,c), parser.ts.arrayOf(t,1)); :}
	;
	
// Type Arguments


type_argument ::=
	reference_type:a {: RESULT = a; :}
	|
	primitive_type:a {: RESULT = a; :}
	;

type_argument_list ::=
	type_argument:a
        {: List<TypeNode> l = new LinkedList<>();
           l.add(a);
           RESULT = l; 
         :}
	|	
    type_argument_list:a COMMA type_argument:b
        {: RESULT = a;
           a.add(b);   
         :}
	;

// Class Declarations

override super ::=
	EXTENDS reference_type:a {: RESULT = a; :}
	;

override class_declaration ::=
	modifiers_or_annotations_opt_1:a CLASS:n 
	IDENTIFIER:b type_parameters_opt:c
	super_opt:d interfaces_opt:e where_constraints_opt:f class_body:g
		{:	if (a.parens != null) parser.die(a.parens.pos);
			FlagAnnotations fl = a.flagAnnotations;
			RESULT = parser.nf.ClassDecl(parser.pos(n, e),
				fl.flags(), parser.nf.Id(parser.pos(b), b.getIdentifier()), d, e, g, c, f);
		:}
	;

class_body_opt ::=
    /* empty */ {: RESULT = null; :}
	|	
    class_body:a {: RESULT = a; :}
;   

drop { class_member_declaration ::= modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body; }

extend class_member_declaration ::=
  	class_declaration:a 
	    {: List<ClassMember> l = new LinkedList<>();
	       l.add(a);
	       RESULT = l; :}
	;

// Blocks and Statements

extend block_statement ::=
	interface_declaration:a
        {: List<Stmt> l = new LinkedList<>();
           l.add(parser.nf.LocalClassDecl(parser.pos(a), a));
           RESULT = l; :}
	;

extend statement ::=	
	foreach_statement:a
        {: RESULT = a; :}
	;
    
extend statement_no_short_if ::=
    foreach_statement_no_short_if:a
        {: RESULT = a; :}
	;

// Field Declarations

override variable_declarator_id ::=
	methead_or_vardeclid:a
		{: RESULT = a.toVarDeclarator(); :}
	;

// Method Declarations

override method_header ::=
	modifiers_or_annotations_opt_1:a type:b 
	methead_or_vardeclid:c
	LPAREN formal_parameter_list_opt:e RPAREN 
	dims_opt:f where_constraints_opt:g throws_opt:h
		{:	FlagAnnotations fl = a.flagAnnotations;
			TypeNode retType = a.parens != null ? a.parens.constructType(b) : b;
			RESULT = parser.nf.MethodDecl(parser.pos(b,e,c), fl.flags(),  parser.array(retType, f), c.getMethodName(), e, h, null, c.getMethodTypeParams(), g);
		:}
	|	
	modifiers_or_annotations_opt_1:a dims:b
	methead_or_vardeclid:c
	LPAREN formal_parameter_list_opt:e RPAREN 
	dims_opt:f where_constraints_opt:g throws_opt:h
		{:	if (a.parens == null) parser.die(a.pos.endOf());
			FlagAnnotations fl = a.flagAnnotations;
			TypeNode retType = a.parens.constructArrayType(b);
			RESULT = parser.nf.MethodDecl(parser.pos(a.parens,e,c), fl.flags(),  parser.array(retType, f), c.getMethodName(), e, h, null, c.getMethodTypeParams(), g);
		:}
	|
	modifiers_or_annotations_opt_1:a VOID:b
	methead_or_vardeclid:c
	LPAREN formal_parameter_list_opt:e RPAREN:f
	where_constraints_opt:g throws_opt:h
		{:	if (a.parens != null) parser.die(a.parens.pos);
			FlagAnnotations fl = a.flagAnnotations;
			RESULT = parser.nf.MethodDecl(parser.pos(b,f,c), fl.flags(),  parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), c.getMethodName(), e, h, null, c.getMethodTypeParams(), g);
		:}
	;

// Constructor Declarations

override constructor_declaration ::=
	modifiers_or_annotations_opt_1:a reftype_or_expr:d
	LPAREN formal_parameter_list_opt:e RPAREN where_constraints_opt:h
	throws_opt:f constructor_body:g
		{:	if (a.parens != null) parser.die(a.parens.pos);
			FlagAnnotations fl = a.flagAnnotations;
			// d should be of the form "ID" or "ID[X,Y]"
			if (d instanceof ObjTypeOrExpr) {
				ObjTypeOrExpr objtype = (ObjTypeOrExpr) d;
				if (objtype.prefix != null) parser.die(parser.pos(d)); 
				Id name = objtype.name;
				List<ParamTypeNode> typeParams = null;
				if (objtype.brackets != null) {
					if (objtype.brackets.size() == 1) {
						typeParams = parser.listWithModelsToTypeParams(objtype.brackets.get(0)); 
					} else { parser.die(parser.pos(d)); }
				}
				RESULT = parser.nf.ConstructorDecl(d.pos, fl.flags(),  name, e,f,g, typeParams, h);
			} else {
				parser.die(parser.pos(d));
			}
		:}
	;
	
// Interface Declarations

override interface_declaration ::=
	modifiers_or_annotations_opt_1:a INTERFACE:b
	IDENTIFIER:c type_parameters_opt:d
	extends_interfaces_opt:e where_constraints_opt:f interface_body:g
		{:	if (a.parens != null) parser.die(a.parens.pos);
			FlagAnnotations fl = a.flagAnnotations;
			RESULT = parser.nf.ClassDecl(parser.pos(b,g), fl.setFlag(Flags.INTERFACE).flags(),  parser.nf.Id(parser.pos(c), c.getIdentifier()), null, e, g, d, f);
		:}
/*	|
	AT:a INTERFACE:b IDENTIFIER:c annotation_body:d
		{:	List<TypeNode> superints = new LinkedList<>();
			superints.add(parser.nf.CanonicalTypeNode(parser.pos(b, d), parser.ts.Annotation()));
			RESULT = parser.nf.ClassDecl(parser.pos(a, d), Flags.INTERFACE.set(JL5Flags.ANNOTATION), null, parser.nf.Id(parser.pos(c), c.getIdentifier()), null, superints, d, null);
		:}
	|
	modifiers_or_annotations_1:a AT:b INTERFACE IDENTIFIER:d annotation_body:e
		{:	if (a.parens != null) parser.die(a.parens.pos);
			FlagAnnotations fl = a.flagAnnotations;
			List<TypeNode> superints = parser.<TypeNode> makeList(parser.nf.CanonicalTypeNode(parser.pos(b, e), parser.ts.Annotation()));
			RESULT = parser.nf.ClassDecl(parser.pos(b, d), fl.setFlag(Flags.INTERFACE.set(JL5Flags.ANNOTATION)).flags(),  parser.nf.Id(parser.pos(d), d.getIdentifier()), null, superints, e, null);
		:}
*/	;

// Expressions

override primary_no_new_array ::=
		primary_no_new_array_or_this:a
		{: RESULT = a; :}
	|	THIS:a
		{: RESULT = parser.nf.This(parser.pos(a)); :}
	;
primary_no_new_array_or_this ::=
		field_access:a
		{: RESULT = a; :}
	|	primary_no_new_array_or_this_or_field_access:a
		{: RESULT = a; :}
	;
primary_no_new_array_or_this_or_field_access ::=
		literal:a
		{: RESULT = a; :}
	|	LPAREN reftype_or_expr:a RPAREN
		{: RESULT = a.toExpr(); :}
	|	LPAREN expression_nn:a RPAREN
		{: RESULT = a; :}
	|	class_instance_creation_expression:a
		{: RESULT = a; :}
/*	|	field_access:a
	We avoid rush into an early decision about whether "primary.ID[id]" is 
	an array access or start of a method invocation expression. The key here
	is not to reduce "primary.ID" to field_access when it is encountered. 
*/
	|	method_invocation:a
		{: RESULT = a; :}
	|	array_access:a
		{: RESULT = a; :}
	|	reftype_or_expr:a DOT THIS:c // "a" should be a name
		{: parser.checkCompoundName(a);
		   RESULT = parser.nf.This(parser.pos(a,c,c), a.toType());
		:}
	|	VOID:a DOT CLASS:c
		{: RESULT = parser.nf.ClassLit(parser.pos(a,c,c), parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Void())); :}
	|	primitive_type:a DOT CLASS:c
		{: RESULT = parser.nf.ClassLit(parser.pos(a,c,c), a); :}
	|	primitive_array_type:a DOT CLASS:c
		{: RESULT = parser.nf.ClassLit(parser.pos(a,c,c), a); :}
	|	reftype_or_expr:a DOT CLASS:c // "a" should be a name or name dims
		{: RESULT = parser.nf.ClassLit(parser.pos(a,c,c), a.toType()); :}
	;
	
/////////////////////////////////////////////////////
// Below we replace name with reftype_or_expr in productions for xx_expression_nn

postfix_expression_nn ::=
		primary:a
        {: RESULT = a; :}
	// the 'name' production was removed here.
	|	postincrement_expression:a
        {: RESULT = a; :}
	|	postdecrement_expression:a
        {: RESULT = a; :}
	;
unary_expression_nn ::=
		preincrement_expression:a
        {: RESULT = a; :}
	|	predecrement_expression:a
        {: RESULT = a; :}
	|	PLUS:a unary_expression:b
        {: RESULT = parser.nf.Unary(parser.pos(a, b, b), Unary.POS, b); :}
	|	MINUS:a unary_expression:b
        {: RESULT = parser.nf.Unary(parser.pos(a, b, b), Unary.NEG, b); :}
	|	MINUS:a boundary_literal:b
        {: RESULT = parser.nf.Unary(parser.pos(a, b, b), Unary.NEG, b); :}
	|	unary_expression_not_plus_minus_nn:a
        {: RESULT = a; :}
	;
unary_expression_not_plus_minus_nn ::=
		postfix_expression_nn:a
        {: RESULT = a; :}
	|	COMP:a unary_expression:b
        {: RESULT = parser.nf.Unary(parser.pos(a,b,b), Unary.BIT_NOT, b); :}
	|	NOT:a unary_expression:b
        {: RESULT = parser.nf.Unary(parser.pos(a,b,b), Unary.NOT, b); :}
	|	cast_expression:a
        {: RESULT = a; :}
	;

multiplicative_expression_nn ::=
		unary_expression_nn:a
        {: RESULT = a; :}
    |	multiplicative_expression_nn:a MULT unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.MUL, c); :}
	|	multiplicative_expression_nn:a DIV unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.DIV, c); :}
	|	multiplicative_expression_nn:a MOD unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.MOD, c); :}
	|	reftype_or_expr:a MULT unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.MUL, c); :}
	|	reftype_or_expr:a DIV unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.DIV, c); :}
	|	reftype_or_expr:a MOD unary_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.MOD, c); :}
	;

additive_expression_nn ::=
		multiplicative_expression_nn:a
        {: RESULT = a; :}
	|	additive_expression_nn:a PLUS multiplicative_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.ADD, c); :}
	|	additive_expression_nn:a MINUS multiplicative_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.SUB, c); :}
    |	reftype_or_expr:a PLUS multiplicative_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.ADD, c); :}
	|	reftype_or_expr:a MINUS multiplicative_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.SUB, c); :}
	;
	
shift_expression_nn ::=
		additive_expression_nn:a
        {: RESULT = a; :}
	|	shift_expression_nn:a LSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.SHL, c); :}
	|	shift_expression_nn:a RSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.SHR, c); :}
	|	shift_expression_nn:a URSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.USHR, c); :}
    |	reftype_or_expr:a LSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.SHL, c); :}
	|	reftype_or_expr:a RSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.SHR, c); :}
	|	reftype_or_expr:a URSHIFT additive_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.USHR, c); :}
    ;

relational_expression_nn ::=
		shift_expression_nn:a
        {: RESULT = a; :}
    |	shift_expression_nn:a LT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LT, c); :}
	|	shift_expression_nn:a GT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GT, c); :}
	|	relational_expression_nn:a LTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LE, c); :}
	|	relational_expression_nn:a GTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GE, c); :}
	|	reftype_or_expr:a LT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.LT, c); :}
	|	reftype_or_expr:a GT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.GT, c); :}
	|	reftype_or_expr:a LTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.LE, c); :}
	|	reftype_or_expr:a GTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.GE, c); :}
	;

instanceof_expression_nn ::=
		relational_expression_nn:a
        {: RESULT = a; :}
	|	instanceof_expression_nn:a INSTANCEOF reference_type:c
        {: RESULT = parser.nf.Instanceof(parser.pos(a, c), a, c); :}
    |	reftype_or_expr:a INSTANCEOF reference_type:c
        {: RESULT = parser.nf.Instanceof(parser.pos(a, c), a.toExpr(), c); :}
	;

equality_expression_nn ::=
		instanceof_expression_nn:a
        {: RESULT = a; :}
	|	equality_expression_nn:a EQEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.EQ, c); :}
	|	equality_expression_nn:a NOTEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.NE, c); :}
    |	reftype_or_expr:a EQEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.EQ, c); :}
	|	reftype_or_expr:a NOTEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.NE, c); :}
	;

and_expression_nn ::=
		equality_expression_nn:a
        {: RESULT = a; :}
	|	and_expression_nn:a AND equality_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.BIT_AND, c); :}
	|	reftype_or_expr:a AND equality_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_AND, c); :}
	;

exclusive_or_expression_nn ::=
		and_expression_nn:a
        {: RESULT = a; :}
	|	exclusive_or_expression_nn:a XOR and_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.BIT_XOR, c); :}
	|	reftype_or_expr:a XOR and_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_XOR, c); :}
	;

inclusive_or_expression_nn ::=
		exclusive_or_expression_nn:a
        {: RESULT = a; :}
	|	inclusive_or_expression_nn:a OR exclusive_or_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.BIT_OR, c); :}
    |	reftype_or_expr:a OR exclusive_or_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_OR, c); :}
	;

conditional_and_expression_nn ::=
		inclusive_or_expression_nn:a
        {: RESULT = a; :}
	|	conditional_and_expression_nn:a ANDAND inclusive_or_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.COND_AND, c); :}
	|	reftype_or_expr:a ANDAND inclusive_or_expression:c
    	{: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.COND_AND, c); :}
	;	

conditional_or_expression_nn ::=
		conditional_and_expression_nn:a
        {: RESULT = a; :}
	|	conditional_or_expression_nn:a OROR conditional_and_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.COND_OR, c); :}
	|	reftype_or_expr:a OROR conditional_and_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.COND_OR, c); :}
	;
	
conditional_expression_nn ::=
		conditional_or_expression_nn:a
        {: RESULT = a; :}
	|	conditional_or_expression_nn:a QUESTION expression:c 
			COLON conditional_expression:e
        {: RESULT = parser.nf.Conditional(parser.pos(a, e), a, c, e); :}
	|	reftype_or_expr:a QUESTION expression:c COLON conditional_expression:e
        {: RESULT = parser.nf.Conditional(parser.pos(a, e), a.toExpr(), c, e); :}
	;
	
assignment_expression_nn ::=
		conditional_expression_nn:a
        {: RESULT = a; :}
	|	assignment:a 
        {: RESULT = a; :}
	;
expression_nn ::=
		assignment_expression_nn:a
    	{: RESULT = a; :}
	;

/////////////////////////////////////////////////////

override relational_expression ::=
		shift_expression:a
        {: RESULT = a; :}
	|	relational_expression:a LT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LT, c); :}
	|	relational_expression:a GT shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GT, c); :}
	|	relational_expression:a LTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.LE, c); :}
	|	relational_expression:a GTEQ shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.GE, c); :}
    ;

instanceof_expression ::=
		relational_expression:a
        {: RESULT = a; :}
	|	instanceof_expression:a INSTANCEOF reference_type:c
        {: RESULT = parser.nf.Instanceof(parser.pos(a, c), a, c); :}
	;

override equality_expression ::=
		instanceof_expression:a
        {: RESULT = a; :}
	|	equality_expression:a EQEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.EQ, c); :}
	|	equality_expression:a NOTEQ instanceof_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a, Binary.NE, c); :}
	;

override array_creation_expression ::=
					// NewArray
		NEW:n primitive_type:a dim_exprs:b dims_opt:c
		{: RESULT = parser.nf.NewArray(parser.pos(n, b), a, b, c.intValue()); :}
	|	NEW:a objtype_or_expr:b dims_opt:c
		{: RESULT = b.toNewArray(a,c); :}
	|	NEW:a existential_arraybase:b dim_exprs:c dims_opt:d
		{: RESULT = parser.nf.NewArray(parser.pos(a,c), b, c, d); :}
	|	initialized_array_creation_expression:a
		{: RESULT = a; :}
	;

initialized_array_creation_expression ::=
		NEW:a primitive_type:b dims:c array_initializer:d
        {: RESULT = parser.nf.NewArray(parser.pos(a, d), b, Collections.<Expr> emptyList(), c.intValue(), d); :}
	|	NEW:a objtype_or_expr:b dims:c array_initializer:d
		{: RESULT = parser.nf.NewArray(parser.pos(a, d), b.toType(), Collections.<Expr> emptyList(), c.intValue(), d); :}
	|	NEW:a existential_arraybase:b dims:c array_initializer:d
		{: RESULT = parser.nf.NewArray(parser.pos(a,d), b, c, d); :}
	;

override class_instance_creation_expression ::=
		NEW:a objtype_or_expr:b LPAREN argument_list_opt:d RPAREN class_body_opt:f
		{:
			if (b.brackets == null) { // new XXX.ID
				RESULT = parser.nf.New(parser.pos(a), b.toType(), d, f);
			} else if (b.brackets.size() == 1) { // new XXX.ID[X] ===> ambiguous
				ListWithModels onlyBracket = b.brackets.get(0);
				TypeNode base = new ObjTypeOrExpr(parser, parser.pos(b), b.prefix, b.name).toType();
				RESULT = parser.nf.AmbNew(parser.pos(a), null, base, parser.listToTypes(onlyBracket.list), onlyBracket.models, d, f);
			} else if (b.brackets.size() == 2) { // new XXX.ID[X][X]
				ObjTypeOrExpr objtype = new ObjTypeOrExpr(parser, parser.pos(b), b.prefix, b.name);
				objtype.addBracket(b.brackets.get(0));
				TypeNode tn = objtype.toType();
				RESULT = parser.nf.New(parser.pos(a), tn, parser.listToTypes(b.brackets.get(1).list), b.brackets.get(1).models, d, f);
			} else {
				parser.die(parser.pos(b));
			}
		:}

/*	|	NEW:a objtype_or_expr:b LBRACK RBRACK:c LPAREN argument_list_opt:e RPAREN class_body_opt:f
			// new xxx.ID[](...)
		{:
			if (b.brackets != null) { parser.die(parser.pos(b)); }
			else { 
				TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(b, c), b.toType());
				RESULT = parser.nf.New(parser.pos(a), Collections.<TypeNode>emptyList(), tn, e, f);
			}
		:}
	|	NEW:a objtype_or_expr:b dims:c generic_inst_args:d LPAREN argument_list_opt:e RPAREN class_body_opt:f
			// new XXX.ID[][X]
		{:
			if (b.brackets != null || c.intValue() != 1) { parser.die(parser.pos(b)); }
			else {
				TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(b, c), b.toType()); 
				RESULT = parser.nf.New(parser.pos(a), tn, d.typeArgs, d.modelArgs, e, f);
			}
		:}	
*/	|
	primary_no_new_array_or_this_or_field_access:a DOT NEW:b IDENTIFIER:c
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier())); 
			RESULT = parser.nf.New(parser.pos(a,j,b), a, id.toType(), h, j);
		:}
	|	primary_no_new_array_or_this_or_field_access:a DOT NEW:b IDENTIFIER:c generic_inst_args:d
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[X] ===> ambiguous
		{:
			TypeNode base = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier())).toType(); 
			RESULT = parser.nf.AmbNew(parser.pos(a,j,b), a, base, d.typeArgs, d.modelArgs, h, j);
		:}
	|	primary_no_new_array_or_this_or_field_access:a DOT NEW:b IDENTIFIER:c generic_inst_args:d generic_inst_args:e
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[X][X]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(c), id.toType(), d.typeArgs, d.modelArgs);
			RESULT = parser.nf.New(parser.pos(a,j,b), a, tn, e.typeArgs, e.modelArgs, h, j);
		:}
/*	|	primary_no_new_array_or_this_or_field_access:a DOT NEW:b IDENTIFIER:c LBRACK RBRACK:d
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(c, d), id.toType());
			RESULT = parser.nf.New(parser.pos(a,j,b), a, tn, h, j);
		:}
	|	primary_no_new_array_or_this_or_field_access:a DOT NEW:b IDENTIFIER:c LBRACK RBRACK:d generic_inst_args:e
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[][X]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(c, d), id.toType());
			RESULT = parser.nf.New(parser.pos(a,j,b), a, tn, e.typeArgs, e.modelArgs, h, j);
		:}
			
*/	|	property_access:a DOT NEW:b IDENTIFIER:c
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier())); 
			RESULT = parser.nf.New(parser.pos(a,j,b), a.toExpr(), id.toType(), h, j);
		:}
	|	property_access:a DOT NEW:b IDENTIFIER:c generic_inst_args:d
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[X] ===> ambiguous
		{:
			TypeNode base = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier())).toType(); 
			RESULT = parser.nf.AmbNew(parser.pos(a,j,b), a.toExpr(), base, d.typeArgs, d.modelArgs, h, j);
		:}
	|	property_access:a DOT NEW:b IDENTIFIER:c generic_inst_args:d generic_inst_args:e
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[X][X]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(c), id.toType(), d.typeArgs, d.modelArgs);
			RESULT = parser.nf.New(parser.pos(a,j,b), a.toExpr(), tn, e.typeArgs, e.modelArgs, h, j);
		:}
/*	|	property_access:a DOT NEW:b IDENTIFIER:c LBRACK RBRACK:d
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(c, d), id.toType());
			RESULT = parser.nf.New(parser.pos(a,j,b), a.toExpr(), tn, h, j);
		:}
	|	property_access:a DOT NEW:b IDENTIFIER:c LBRACK RBRACK:d generic_inst_args:e
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[][X]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(c, d), id.toType());
			RESULT = parser.nf.New(parser.pos(a,j,b), a.toExpr(), tn, e.typeArgs, e.modelArgs, h, j);
		:}
			
*/	|	THIS:a DOT NEW:b IDENTIFIER:c
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier())); 
			RESULT = parser.nf.New(parser.pos(a,j,b), parser.nf.This(parser.pos(a)), id.toType(), h, j);
		:}
	|	THIS:a DOT NEW:b IDENTIFIER:c generic_inst_args:d
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[X] ===> ambiguous
		{:
			TypeNode base = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier())).toType(); 
			RESULT = parser.nf.AmbNew(parser.pos(a,j,b), parser.nf.This(parser.pos(a)), base, d.typeArgs, d.modelArgs, h, j);
		:}
	|	THIS:a DOT NEW:b IDENTIFIER:c generic_inst_args:d generic_inst_args:e
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[X][X]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(c), id.toType(), d.typeArgs, d.modelArgs);
			RESULT = parser.nf.New(parser.pos(a,j,b), parser.nf.This(parser.pos(a)), tn, e.typeArgs, e.modelArgs, h, j);
		:}
/*	|	THIS:a DOT NEW:b IDENTIFIER:c LBRACK RBRACK:d
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(c, d), id.toType());
			RESULT = parser.nf.New(parser.pos(a,j,b), parser.nf.This(parser.pos(a)), tn, h, j);
		:}
	|	THIS:a DOT NEW:b IDENTIFIER:c LBRACK RBRACK:d generic_inst_args:e
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[][X]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(c, d), id.toType());
			RESULT = parser.nf.New(parser.pos(a,j,b), parser.nf.This(parser.pos(a)), tn, e.typeArgs, e.modelArgs, h, j);
		:}
*/			
	|	reftype_or_expr:a DOT NEW:b IDENTIFIER:c
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier())); 
			RESULT = parser.nf.New(parser.pos(a,j,b), a.toExpr(), id.toType(), h, j);
		:}
	|	reftype_or_expr:a DOT NEW:b IDENTIFIER:c generic_inst_args:d
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[X] ===> ambiguous
		{:
			TypeNode base = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier())).toType(); 
			RESULT = parser.nf.AmbNew(parser.pos(a,j,b), a.toExpr(), base, d.typeArgs, d.modelArgs, h, j);
		:}
	|	reftype_or_expr:a DOT NEW:b IDENTIFIER:c generic_inst_args:d generic_inst_args:e
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[X][X]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbTypeInstantiation(parser.pos(c), id.toType(), d.typeArgs, d.modelArgs);
			RESULT = parser.nf.New(parser.pos(a,j,b), a.toExpr(), tn, e.typeArgs, e.modelArgs, h, j);
		:}
/*	|	reftype_or_expr:a DOT NEW:b IDENTIFIER:c LBRACK RBRACK:d
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(c, d), id.toType());
			RESULT = parser.nf.New(parser.pos(a,j,b), a.toExpr(), tn, h, j);
		:}
	|	reftype_or_expr:a DOT NEW:b IDENTIFIER:c LBRACK RBRACK:d generic_inst_args:e
			LPAREN argument_list_opt:h RPAREN class_body_opt:j
			// expr.new ID[][X]
		{:
			Name id = new Name(parser, parser.pos(c), null, parser.nf.Id(parser.pos(c), c.getIdentifier()));
			TypeNode tn = parser.nf.AmbDiamondTypeNode(parser.pos(c, d), id.toType());
			RESULT = parser.nf.New(parser.pos(a,j,b), a.toExpr(), tn, e.typeArgs, e.modelArgs, h, j);
		:}
*/	;

override explicit_constructor_invocation ::=
                    // ConstructorCall
        THIS:a LPAREN argument_list_opt:b RPAREN SEMICOLON:c
		{: RESULT = parser.nf.ThisCall(parser.pos(a, c), b); :}
    |   SUPER:a LPAREN argument_list_opt:b RPAREN SEMICOLON:c
		{: RESULT = parser.nf.SuperCall(parser.pos(a, c), b); :}
	|	primary_no_new_array_or_this_or_field_access:a DOT SUPER:n LPAREN argument_list_opt:b RPAREN SEMICOLON:c
		{: RESULT = parser.nf.SuperCall(parser.pos(a, c, n), a, b); :}
	|	property_access:a DOT SUPER:n LPAREN argument_list_opt:b RPAREN SEMICOLON:c
		{: RESULT = parser.nf.SuperCall(parser.pos(a,c,n), a.toExpr(), b); :}
	|	reftype_or_expr:a DOT SUPER:n LPAREN argument_list_opt:b RPAREN SEMICOLON:c
		{: RESULT = parser.nf.SuperCall(parser.pos(a,c,n), a.toExpr(), b); :}
    // generic constructor invocations
	|	THIS generic_inst_args:a LPAREN argument_list_opt:d RPAREN SEMICOLON:f
		{: RESULT = parser.nf.ThisCall(parser.pos(a, f), a.typeArgs, a.modelArgs, d); :}
	|	SUPER generic_inst_args:a LPAREN argument_list_opt:d RPAREN SEMICOLON:f
        {: RESULT = parser.nf.SuperCall(parser.pos(a, f), a.typeArgs, a.modelArgs, d); :}
	|	primary_no_new_array_or_this_or_field_access:a DOT SUPER:d generic_inst_args:c
			LPAREN argument_list_opt:f RPAREN SEMICOLON:h
		{: RESULT = parser.nf.SuperCall(parser.pos(a, h, d), a, c.typeArgs, c.modelArgs, f); :}
	|	property_access:a DOT SUPER:d generic_inst_args:c
			LPAREN argument_list_opt:f RPAREN SEMICOLON:h
		{: RESULT = parser.nf.SuperCall(parser.pos(a, h, d), a.toExpr(), c.typeArgs, c.modelArgs, f); :}
	|	reftype_or_expr:a DOT SUPER:d generic_inst_args:c 
			LPAREN argument_list_opt:f RPAREN SEMICOLON:h
		{: RESULT = parser.nf.SuperCall(parser.pos(a, h, d), a.toExpr(), c.typeArgs, c.modelArgs, f); :}
	;

override method_invocation ::=
			// Call
	SUPER:a DOT IDENTIFIER:c LPAREN argument_list_opt:e RPAREN:f
		{: RESULT = parser.nf.Call(parser.pos(c,f),
			parser.nf.Super(parser.pos(a)),
			parser.nf.Id(parser.pos(c), c.getIdentifier()), e); :}
	|
	SUPER:a DOT LPAREN objtype_or_expr:p RPAREN generic_inst_args_opt:q
		LPAREN argument_list_opt:e RPAREN:f
		// super.(<expander>.<id>)[<type/model args>](...)
		{:	if (p.prefix == null || p.brackets != null) parser.die(parser.pos(p));
			RESULT = parser.nf.Call(parser.pos(p,f),
				parser.nf.Super(parser.pos(a)),
				p.prefix.toAmbExpanderNode(),
				p.name,
				q == null ? null : q.typeArgs,
				q == null ? null : q.modelArgs, 
				e);
		:}
	|
	THIS:a DOT IDENTIFIER:c LPAREN argument_list_opt:e RPAREN:f
		{: RESULT = parser.nf.Call(parser.pos(c,f),
			parser.nf.This(parser.pos(a)),
			parser.nf.Id(parser.pos(c), c.getIdentifier()), e); :}
	|
	THIS:a DOT LPAREN objtype_or_expr:p RPAREN generic_inst_args_opt:q
		LPAREN argument_list_opt:e RPAREN:f
		{:	if (p.prefix == null || p.brackets != null) parser.die(parser.pos(p));
			RESULT = parser.nf.Call(parser.pos(p,f),
				parser.nf.This(parser.pos(a)),
				p.prefix.toAmbExpanderNode(),
				p.name,
				q == null ? null : q.typeArgs,
				q == null ? null : q.modelArgs, 
				e);
		:}
	|
	primary_no_new_array_or_this_or_field_access:a DOT IDENTIFIER:c 
			LPAREN argument_list_opt:e RPAREN:f
		{: RESULT = parser.nf.Call(parser.pos(c,f), a,
			parser.nf.Id(parser.pos(c), c.getIdentifier()), e); :}
	|
	primary_no_new_array_or_this_or_field_access:a DOT LPAREN objtype_or_expr:p RPAREN 
			generic_inst_args_opt:q LPAREN argument_list_opt:e RPAREN:f
		{:	if (p.prefix == null || p.brackets != null) parser.die(parser.pos(p));
			RESULT = parser.nf.Call(parser.pos(p,f),
				a,
				p.prefix.toAmbExpanderNode(),
				p.name,
				q == null ? null : q.typeArgs,
				q == null ? null : q.modelArgs, 
				e);
		:}
	|
	reftype_or_expr:a LPAREN argument_list_opt:c RPAREN:d
		{:	if (!(a instanceof ObjTypeOrExpr)) { parser.die(parser.pos(a)); } 
			RESULT = ((ObjTypeOrExpr) a).toMethodCall(c, d); :}
	|
	reftype_or_expr:a DOT LPAREN objtype_or_expr:p RPAREN generic_inst_args_opt:q
		LPAREN argument_list_opt:c RPAREN:d
		{:	if (p.prefix == null || p.brackets != null) parser.die(parser.pos(p));
			RESULT = parser.nf.Call(parser.pos(a,d), 
				a.toReceiver(),
				p.prefix.toAmbExpanderNode(),
				p.name,
				q == null ? null : q.typeArgs,
				q == null ? null : q.modelArgs, 
				c);
		:}
	|
	reftype_or_expr:n DOT SUPER:a DOT IDENTIFIER:c LPAREN argument_list_opt:e RPAREN:f
		{: parser.checkCompoundName(n);
		   RESULT = parser.nf.Call(parser.pos(c,f),
			parser.nf.Super(parser.pos(n,a), n.toType()),
			parser.nf.Id(parser.pos(c), c.getIdentifier()), e); :}
	|
	reftype_or_expr:n DOT SUPER:a DOT LPAREN:c objtype_or_expr:p RPAREN
		generic_inst_args_opt:q LPAREN argument_list_opt:e RPAREN:f
		{:	parser.checkCompoundName(n);
			if (p.prefix == null || p.brackets != null) parser.die(parser.pos(p));
			RESULT = parser.nf.Call(parser.pos(p,f),
				parser.nf.Super(parser.pos(n,a), n.toType()),
				p.prefix.toAmbExpanderNode(),
				p.name,
				q == null ? null : q.typeArgs,
				q == null ? null : q.modelArgs, 
				e);
		:}
	|
	property_access:a LBRACK param_or_expr_list_with_models:c RBRACK LPAREN argument_list_opt:f RPAREN:g
		{: RESULT = parser.nf.Call(parser.pos(a,g), a.prefix, a.id, parser.listToTypes(c.list), c.models, f); :}
	;


override cast_expression ::=
	LPAREN:a primitive_type:b RPAREN unary_expression:d
		{: RESULT = parser.nf.Cast(parser.pos(a,d,b), b, d); :}
	|
	LPAREN:a primitive_array_type:b RPAREN unary_expression:d   
		{: RESULT = parser.nf.Cast(parser.pos(a,d,b), b, d); :}
	|
	LPAREN:a reftype_or_expr:b RPAREN unary_expression_not_plus_minus:d
		{: RESULT = parser.nf.Cast(parser.pos(a,d), b.toType(), d); :}
	|
	LPAREN:a use_site_params:b reftype_or_expr:c RPAREN unary_expression_not_plus_minus:e
		{: RESULT = parser.nf.Cast(parser.pos(a,e), parser.existentialTypeNode(b, c.toType()), e); :}
	|
	LPAREN:a existential_arraybase:b dims:c unary_expression_not_plus_minus:d
		{: RESULT = parser.nf.Cast(parser.pos(a,d), parser.array(b, c), d); :}
	|
	LPAREN:a use_site_params:b existential_arraybase:c dims:d unary_expression_not_plus_minus:e
		{: RESULT = parser.nf.Cast(parser.pos(a,e), parser.existentialTypeNode(b, parser.array(c,d)), e); :}
	;

override field_access ::=
	                    // Field
		property_access:a
		{: RESULT = a.toExpr(); :}
/*	|	reftype_or_expr
		This production is not needed here for the same reason as in array_access.
 */
	;

/* property_access represents (the prefix of) the access of a class type's field or 
method. However, note that it does not include the form "P.n", which is one of the 
productions of reftype_or_expr.
*/
property_access ::=
		primary_no_new_array_or_this_or_field_access:a DOT IDENTIFIER:b
		{: RESULT = new PropertyAccess(parser, parser.pos(a,b), a, parser.nf.Id(parser.pos(b), b.getIdentifier())); :}
	|	property_access:a DOT IDENTIFIER:b
		{: RESULT = new PropertyAccess(parser, parser.pos(a,b), a.toExpr(), parser.nf.Id(parser.pos(b), b.getIdentifier())); :}
    |	THIS:a DOT IDENTIFIER:b
    	{: RESULT = new PropertyAccess(parser, parser.pos(a,b), parser.nf.This(parser.pos(a)), parser.nf.Id(parser.pos(b), b.getIdentifier())); :}
    |   SUPER:a DOT IDENTIFIER:b
    	{: RESULT = new PropertyAccess(parser, parser.pos(a,b), parser.nf.Super(parser.pos(a)), parser.nf.Id(parser.pos(b), b.getIdentifier())); :}
	|	reftype_or_expr:a DOT SUPER:b DOT IDENTIFIER:c // was "name DOT SUPER DOT IDENTIFIER"
		{: parser.checkCompoundName(a);
		   RESULT = new PropertyAccess(parser, parser.pos(a,c), parser.nf.Super(parser.pos(a,b), a.toType()), parser.nf.Id(parser.pos(c), c.getIdentifier())); :}
    ;

override array_access ::=
						// ArrayAccess
		primary_no_new_array_or_this_or_field_access:a LBRACK expression:c RBRACK:d
		{: RESULT = parser.nf.ArrayAccess(parser.pos(a,d), a, c); :}
	|	property_access:a LBRACK param_or_expr_list_with_models:c RBRACK:d
						// field_access[expr]
		//{: RESULT = parser.nf.ArrayAccess(parser.pos(a,d), a.toExpr(), parser.listToExpr(c)); :}						
/*	|	reftype_or_expr // was "name LBRACK expression RBRACK"
		
		This production is not necessary and in fact problematic: reftype_or_expr 
		already contains the case of "name LBRACK expression RBRACK", and everywhere 
		an array_access is accepted (e.g., left_hand_side), a reftype_or_expr is 
		used instead.
 */
	|	initialized_array_creation_expression:a LBRACK expression:c RBRACK:d
		{: RESULT = parser.nf.ArrayAccess(parser.pos(a,d), a, c); :}
	;

override left_hand_side ::=
		reftype_or_expr:a // was "name"
		{: RESULT = a.toExpr(); :}
	|	field_access:a
		{: RESULT = a; :}
	|	array_access:a
		{: RESULT = a; :}
	;
        
override postfix_expression ::=
		reftype_or_expr:a
		{: RESULT = a.wrap(); :}
	|	primary:a
		{: RESULT = a; :}
    |   postincrement_expression:a
    	{: RESULT = a; :}
    |   postdecrement_expression:a
    	{: RESULT = a; :}
	;

///////////////////////////////////////////////////////////////////////////////////
// Start adding grammar support for with-clauses for use-site type constraints 

// See field_declaration and local_variable_declaration.

extend return_statement ::=
	RETURN:n expression:a WITH model_argument_list:c SEMICOLON:e
		{: RESULT = parser.nf.Return(parser.pos(n,e), parser.nf.ExprWith(parser.pos(a,c), a, c)); :}
	;

extend statement_expression ::=
		assignment:a WITH model_argument_list:c
	;
 
// Not supporting such with-clauses in parameter passing for now.

/*
extend argument_list ::=
        LPAREN expression:a WITH model_argument_list:c RPAREN
    |   argument_list:a COMMA LPAREN expression:b WITH model_argument_list:c RPAREN
    ;
*/
// End
////////////////////////////////////////////////////////////////////////////////////
  
	
	
/* Represents a non-existential, non-primitive array reference type (excluding array type with an existential ultimate base) 
 * or an expression.
 */
reftype_or_expr ::=
		IDENTIFIER:a
		{: RESULT = new ObjTypeOrExpr(parser, parser.pos(a), parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
	|	reftype_or_expr:a DOT IDENTIFIER:b 
		{:
			if (a instanceof ObjTypeOrExpr) {
				RESULT = new ObjTypeOrExpr(parser, parser.pos(a,b), (ObjTypeOrExpr)a, parser.nf.Id(parser.pos(b), b.getIdentifier()));
			} else {
				parser.die(parser.pos(a,b));
			}
		:}
	|	reftype_or_expr:a LBRACK param_or_expr_list_with_models:b RBRACK
		{:
			if (a instanceof ObjTypeOrExpr) {
				((ObjTypeOrExpr)a).addBracket(b); RESULT = a;
			} else {
				parser.die(parser.pos(a,b));
			}
		:}
	|	reftype_or_expr:a LBRACK RBRACK:c
			// array type
		{: RESULT = new Array(parser, parser.pos(a,c), a.toType()); :}
	;

/* reftype_or_expr plus array type with existential ultimate base.
 * Represents all non-existential, non-primitive array reference types
 */
reftype_or_expr_1 ::=
	reftype_or_expr:a
		{: RESULT = a.toType(); :}
	|
	existential_arraybase:a dims:b
		{: RESULT = parser.array(a, b); :}
	;

/* Represents the following part of a model method signature:
		receiver_type DOT method_id type_parameters
   Only the "method_id" part is not optional.
 */
model_method_partial_sig ::=
	use_site_params_opt:a objtype_or_expr:b
		// receiver type is implicit, or it is a (possibly existential) object type
		{:	TypeNode receiverType = null;
			if (b.prefix != null) receiverType = b.prefix.toType();
			if (a != null) receiverType = parser.existentialTypeNode(a, receiverType);
			Id methodId = b.name;
			List<ParamTypeNode> l = null;
			if (b.brackets != null) {
				if (b.brackets.size() > 1) parser.die(parser.pos(b));
				else l = parser.listWithModelsToTypeParams(b.brackets.get(0));
			}
			RESULT = new ModelMethodPartialSig(parser, parser.pos(b), receiverType, methodId, l);
		:}
	|
	use_site_params_opt:a objtype_or_expr:b dims:c DOT IDENTIFIER:e type_parameters_opt:f
		// receiver type is a (possibly existential) array type with the ultimate base type being a non-existential object type
		{:	TypeNode receiverType = parser.array(b.toType(), c);
			if (a != null) receiverType = parser.existentialTypeNode(a, receiverType);
			Id methodId = parser.nf.Id(parser.pos(e), e.getIdentifier());
			RESULT = new ModelMethodPartialSig(parser, parser.pos(b,e), receiverType, methodId, f);
		:}
	|
	existential_arraybase:b dims:c DOT IDENTIFIER:e type_parameters_opt:f
		// receiver type is a non-existential array type with the ultimate base type being existential
		{:	TypeNode receiverType = parser.array(b, c);
			Id methodId = parser.nf.Id(parser.pos(e), e.getIdentifier());
			RESULT = new ModelMethodPartialSig(parser, parser.pos(b,e), receiverType, methodId, f);
		:}
	|
	use_site_params:a existential_arraybase:b dims:c DOT IDENTIFIER:e type_parameters_opt:f
		// receiver type is an existential array type with the ultimate base type being existential	
		{:	TypeNode receiverType = parser.array(b, c);
			receiverType = parser.existentialTypeNode(a, receiverType);
			Id methodId = parser.nf.Id(parser.pos(e), e.getIdentifier());
			RESULT = new ModelMethodPartialSig(parser, parser.pos(b,e), receiverType, methodId, f);
		:}
	|
	primitive_array_type:b DOT IDENTIFIER:e type_parameters_opt:f
		// receiver type is a primitive array type
		{:	Id methodId = parser.nf.Id(parser.pos(e), e.getIdentifier());
			RESULT = new ModelMethodPartialSig(parser, parser.pos(b,e), b, methodId, f);
		:}
	|
	primitive_type:b DOT IDENTIFIER:e type_parameters_opt:f
		// receiver type is a primitive type
		{:	Id methodId = parser.nf.Id(parser.pos(e), e.getIdentifier());
			RESULT = new ModelMethodPartialSig(parser, parser.pos(b,e), b, methodId, f);
		:}
	;


/* Represents a non-existential object type or an expression.
*/
objtype_or_expr ::=
		IDENTIFIER:a
		{: RESULT = new ObjTypeOrExpr(parser, parser.pos(a), parser.nf.Id(parser.pos(a), a.getIdentifier())); :}
	|	objtype_or_expr:a DOT IDENTIFIER:b
		{:
			if (a instanceof ObjTypeOrExpr) {
				RESULT = new ObjTypeOrExpr(parser, parser.pos(a,b), (ObjTypeOrExpr)a, parser.nf.Id(parser.pos(b), b.getIdentifier()));
			} else {
				parser.die(parser.pos(a,b));
			}
		:}
	|	objtype_or_expr:a LBRACK param_or_expr_list_with_models:b RBRACK
		{:
			if (a instanceof ObjTypeOrExpr) {
				((ObjTypeOrExpr)a).addBracket(b); RESULT = a;
			} else {
				parser.die(parser.pos(a,b));
			}
		:}
	;

/* methead_or_vardeclid can be part of a method header or field declaration.
 */ 
methead_or_vardeclid ::=
		IDENTIFIER:a
		{: 
		  RESULT = new NameParams_or_VarDeclId(parser, parser.pos(a), parser.nf.Id(parser.pos(a), a.getIdentifier()));
		:}
	|	methead_or_vardeclid:a LBRACK type_parameter_list:b RBRACK
			// Method name and type parameter list
		{: RESULT = new NameParams_or_VarDeclId(parser, parser.pos(a), a, b); :}
	|	methead_or_vardeclid:a LBRACK RBRACK
			// Variable declarator id of an array
		{: RESULT = new NameParams_or_VarDeclId(parser, parser.pos(a), a); :}
	;
	
	
// Start production rules for annotations
/*
annotation_body ::=
    LBRACE:n annotation_type_element_declarations_opt:a RBRACE:d
        {: RESULT = parser.nf.ClassBody(parser.pos(n,d), a); :}
;

annotation_type_element_declarations_opt ::=
        {: RESULT = new LinkedList<>(); :}
    |
    annotation_type_element_declarations:a
        {: RESULT = a; :}
;

annotation_type_element_declarations ::=
    annotation_type_element_declaration:a
        {: RESULT = a; :}
    |
    annotation_type_element_declarations:a annotation_type_element_declaration:b
        {: RESULT = a;
           a.addAll(b); :}
;

element_value_array_initializer ::=
    LBRACE:n element_values:a COMMA RBRACE:d
        {: RESULT = parser.nf.ElementValueArrayInit(parser.pos(n, d), a); :}
    |
    LBRACE:n element_values:a RBRACE:d
        {: RESULT = parser.nf.ElementValueArrayInit(parser.pos(n, d), a); :}
    |
    LBRACE:n COMMA RBRACE:d
        {: RESULT = parser.nf.ElementValueArrayInit(parser.pos(n, d)); :}
    |
    LBRACE:n RBRACE:d
        {: RESULT = parser.nf.ElementValueArrayInit(parser.pos(n, d)); :}
;

element_value_pairs_opt ::=
        {: RESULT = new LinkedList<>(); :}
    |
    element_value_pairs:a
        {: RESULT = a; :}
;

element_value_pairs ::=
    element_value_pair:a
        {: List<ElementValuePair> l = new LinkedList<>();
           l.add(a);
           RESULT = l;
        :}
    |
    element_value_pairs:a COMMA element_value_pair:b
        {: a.add(b);
           RESULT = a; :}
;
element_value_pair ::=
    IDENTIFIER:a EQ element_value:b
    {: RESULT = parser.nf.ElementValuePair(parser.pos(a,b), parser.nf.Id(parser.pos(a), a.getIdentifier()), b); :}
;
*/