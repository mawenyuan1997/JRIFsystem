\documentclass[10pt]{article}
\usepackage{mathtools} 

\title{KAT in Jrif}

\begin{document}
\maketitle
\begin{itemize}
\item We use KAT expressions to specify reactive information flow policies. KAT expressions are more expressive than RIF automata, which are used in the Jrif implementation.
\item Because the input alphabet of a KAT automaton is exponentially large (w.r.t., primitive tests),a simple equivalence algorithm (that goes through all alphabet) is not tractable in practice. Instead we need to use its symbolic version.
\item We use the Antimirov's algorithm to convert KAT expressions into symbolic automata. See ``Symbolic Algorithms for Language Equivalence and Kleene Algebra with Tests'' (pous.pdf) and ``Partial derivatives of regular expressions and finite automaton constructions" (antimirov.pdf). With this algorithm, we do not need to normalize expressions.
\item There is not an algorithm that creates linear forms of KAT expressions, in an analogous way that Antimirov (antimirov.pdf) computes linear forms for regular expression, in order to compute partial derivatives. But the Pous algorithm for symbolic partial derivatives for KAT expressions seems to have the same desirable effect: isolates atoms and actions that actually appear in the KAT expression, instead of performing exhaustive search on all possible atom-action pairs (as it is being done with the derivatives algorithm).
\item This algorithm is based on the idea of derivatives: ``Regular-expression derivatives reexamined'' (re-deriv.pdf
).
\item We first convert expressions to automata and then compare the restrictiveness of automata.
\item For the conversion of expressions to automata we need to use ``smart constructors''. For example, when converting \emph{1e}, it suffices to convert \emph{e} and when converting \emph{0e}, it suffices to convert \emph{0}.
\item We might need to use hashconsing of expressions to achieve a faster syntactic equivalence routine. For example, when using sets of expressions, we need to decide if a new element is already in the set to avoid duplication.
\item Java might have a BDD libabry where leafs can be states.
\item We could compute the product of syntactic automata as an ``apply'' function on BDDs.
\item For an assignment $x:=y$, if the type of $x$ is $\{e_1,e_2\}$ and the type of $y$ is $e_y$, then the check $(e_1\geq e)\;\wedge\;(e_2\geq e_y)$ is more conservative than the check $e_1\sqcup e_2\geq e_y$.
\item We are interested in the performance of the compilation. So, we could keep the first Brzozowski implementation for comparison reasons.
\end{itemize}

\section*{TODO}
\begin{itemize}
\item Follow Pous paper (``Symbolic Algorithms for Language Equivalence and Kleene Algebra with Tests'').
\begin{itemize}
\item Implement function KAT$\rightarrow$SyKAT. So, we need to (i) find an algorithm that converts expressions on tests to Boolean BDDs and to (ii) find JAVA structures to implement BDDs. We could look at the implementation of Pous for some help (PousSymKat directory):\\
http://perso.ens-lyon.fr/damien.pous/symbolickat/
\begin{itemize}
\item To convert a boolean expression into a boolean BDD we use Figure 2 of pous.pdf inductively on the boolean expression. See 19-bdds.pdf for a nice schematic explanation of the algorithm.
\end{itemize}
\item Use Section 4.2 from Pous to make the conversion algorithm (from KAt expressions to NFAs) symbolic.
\item Use Section 3.2 from Pous and Section 4.2 from Antimirov to extend the conversion algorithm to produce DFAs.
\item Use Section 3.2 from Pous to compare DFAs.
\end{itemize}  
\item Enrich notes with the theoretical background for KAT and authorization strings.
\item Come up with policies that take advantage of the expressive power of KAT. We need to show that non-determinism is useful. If non-determinism is useful, then we could restrict the syntax of KAT (i.e., guarded KAT) and get more efficient procedures for converting to automata and for comparison.
\end{itemize}
\newpage
\begin{minipage}{0.45\textwidth}
Regular expression:\\
\begin{align*}
    l\odot 0&=\emptyset\\
    l\odot \lambda&= l\\
    \emptyset\odot t&=\emptyset\\
    \{\langle x,0\rangle\}\odot t&=\{\langle x,0\rangle\}\\
    \{\langle x,\lambda\rangle\}\odot t&=\{\langle x,t\rangle\}\\
    \{\langle x,p\rangle\}\odot t&=\{\langle x,p\cdot t\rangle\}\\
    (l\cup l')\odot t&=(l\odot t)\cup (l'\odot t)
\end{align*}
\begin{align*}
    lf(0)&=\emptyset\\
    lf(\lambda)&=\emptyset\\
    lf(x)&=\{\langle x,\lambda\rangle\}\\
    lf(r+t)&=lf(r)\cup lf(t)\\
    lf(r^*)&=lf(r)\odot r^*\\
    lf(r_0\cdot t)&=lf(r_0)\odot t\\
    lf(r_1\cdot t)&=lf(r_1)\odot t\cup lf(t)
\end{align*}
$r_1$ contains $\lambda$. $r_0$ does not.
\end{minipage}%
\hfill
\begin{minipage}{0.45\textwidth}
KAT expression:\\
\begin{align*}
    l\odot 0&=\emptyset\\
    l\odot 1&= l\\
    \emptyset\odot t&=\emptyset\\
    \{\langle \alpha p,0\rangle\}\odot t&=\{\langle \alpha p,0\rangle\}\\
    \{\langle \alpha p,1\rangle\}\odot t&=\{\langle \alpha p,t\rangle\}\\
    \{\langle \alpha p,p\rangle\}\odot t&=\{\langle \alpha p,p\cdot t\rangle\}\\
    (l\cup l')\odot t&=(l\odot t)\cup (l'\odot t)
\end{align*}
\begin{align*}
    lf(0)&=\emptyset\\
    lf(1)&=\emptyset\\
    lf(b)&=\emptyset\\
    lf(p)&=\{\langle \alpha p,1\rangle|\alpha\in At\}\\
    lf(r+t)&=lf(r)\cup lf(t)\\
    lf(r^*)&=lf(r)\odot r^*\\
    lf(r\cdot t)&=lf(r)\odot t\\
    &\cup \{\langle \alpha p,t'\rangle|\langle \alpha p,t'\rangle\in lf(t), E_{\alpha}(r)=1\}
\end{align*}
\end{minipage}%
\end{document}