// Assumes jif.jar is in classpath
include "jif/parse/jif.ppg"

package jrif.parse;

import jrif.types.JrifTypeSystem;
import jrif.ast.*;
import jif.parse.*;
import KATautomata.KAT.*;
import KATautomata.KAToperator.*;
import KATautomata.SyKAT.*;
import KATautomata.SyKAToperator.*;
import KATautomata.utility.*;
import polyglot.lex.IntegerLiteral;

parser Grm extends jif.parse.Grm {:
    public final JrifTypeSystem ts;
    public final JrifNodeFactory nf;

    public Grm(Lexer l, JrifTypeSystem t, JrifNodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = t;
        nf = n;
    }
:};

terminal Token RECLASSIFY;
terminal Token RIF;
terminal Token RIFI;
terminal Token TR;
terminal IntegerLiteral NUMBER;


non terminal RifPolicyNode rif_label;
non terminal RifiPolicyNode rifi_label;
non terminal KatExprNode kat_expr;
non terminal KatTestNode boolean;
non terminal List principal_set;

precedence left PLUS, OR;
precedence left XOR, AND;
precedence left COMP;
start with goal;

extend label_component ::=
        rif_label:a
            {: RESULT = a; :}
    |   rifi_label:a
            {: RESULT = a; :}
    ;

rif_label ::=
     RIF COLON kat_expr:a
     {:RESULT = new RifPolicyNode_c(parser.pos(a), a); :}
   ;

rifi_label ::=
     RIFI COLON kat_expr:a
     {:RESULT = new RifiPolicyNode_c(parser.pos(a), a); :}
   ;

principal_set ::=
         LBRACE:x RBRACE:y
            {: List l = new LinkedList<PrincipalNode>();
               l.add(parser.nf.CanonicalPrincipalNode(parser.pos(x), parser.ts.topPrincipal(parser.pos(x))));
               RESULT = l; :}
    |    LBRACE:x principal_list:a RBRACE:y
            {: RESULT = a; :}
    ;

kat_expr ::=
      kat_expr:p1 PLUS kat_expr:p2        {: RESULT = new KatPlusNode(parser.pos(p1,p2), p1, p2); :}
    | kat_expr:p1 XOR kat_expr:p2         {: RESULT = new KatConcatNode(parser.pos(p1,p2), p1, p2); :}
    | kat_expr:p MULT                   {: RESULT = new KatStarNode(parser.pos(p), p); :}
    | LPAREN kat_expr:p RPAREN          {: RESULT = p; :}
    | boolean:b                        {: RESULT = b; :}
    | IDENTIFIER:p                     {: RESULT = new KatActionNode(parser.pos(p), p.getIdentifier()); :}
    ;

boolean ::=
      principal_set:p                 {: RESULT = new KatAtomNode(parser.pos(p), p); :}
    //| accesspath_no_id:p              {: RESULT = new KatAtomNode(parser.pos(p), p); :}
    | NUMBER:p                            {:
                                        int val = p.symbol();
                                        if (val != 0 && val != 1) {
                                            parser.report_error ("Expected 0 or 1", parser.pos(p));
                                            if (true) throw new Exception();
                                        }
                                        if (val == 0) RESULT = new KatZeroNode(parser.pos(p));
                                        else RESULT = new KatOneNode(parser.pos(p));
                                       :}
    | boolean:b1 OR boolean:b2        {: RESULT = new KatOrNode(parser.pos(b1,b2), b1, b2); :}
    | boolean:b1 AND boolean:b2       {: RESULT = new KatAndNode(parser.pos(b1,b2), b1, b2); :}
    | LBRACK boolean:b RBRACK         {: RESULT = b; :}
    | COMP boolean:b                  {: RESULT = new KatNegateNode(parser.pos(b), b); :}
    ;



 